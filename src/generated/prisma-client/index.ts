// Code generated by Prisma (prisma@1.18.1). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode, GraphQLSchema } from "graphql";
import { IResolvers } from "graphql-tools/dist/Interfaces";
import { makePrismaClientClass, BaseClientOptions } from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  amenities: (where?: AmenitiesWhereInput) => Promise<boolean>;
  booking: (where?: BookingWhereInput) => Promise<boolean>;
  city: (where?: CityWhereInput) => Promise<boolean>;
  creditCardInformation: (
    where?: CreditCardInformationWhereInput
  ) => Promise<boolean>;
  experience: (where?: ExperienceWhereInput) => Promise<boolean>;
  experienceCategory: (
    where?: ExperienceCategoryWhereInput
  ) => Promise<boolean>;
  guestRequirements: (where?: GuestRequirementsWhereInput) => Promise<boolean>;
  houseRules: (where?: HouseRulesWhereInput) => Promise<boolean>;
  location: (where?: LocationWhereInput) => Promise<boolean>;
  message: (where?: MessageWhereInput) => Promise<boolean>;
  neighbourhood: (where?: NeighbourhoodWhereInput) => Promise<boolean>;
  notification: (where?: NotificationWhereInput) => Promise<boolean>;
  payment: (where?: PaymentWhereInput) => Promise<boolean>;
  paymentAccount: (where?: PaymentAccountWhereInput) => Promise<boolean>;
  paypalInformation: (where?: PaypalInformationWhereInput) => Promise<boolean>;
  picture: (where?: PictureWhereInput) => Promise<boolean>;
  place: (where?: PlaceWhereInput) => Promise<boolean>;
  policies: (where?: PoliciesWhereInput) => Promise<boolean>;
  pricing: (where?: PricingWhereInput) => Promise<boolean>;
  restaurant: (where?: RestaurantWhereInput) => Promise<boolean>;
  review: (where?: ReviewWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
  views: (where?: ViewsWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;
  $getAbstractResolvers(filterSchema?: GraphQLSchema | string): IResolvers;

  /**
   * Queries
   */

  amenities: (where: AmenitiesWhereUniqueInput) => Amenities;
  amenitieses: (
    args?: {
      where?: AmenitiesWhereInput;
      orderBy?: AmenitiesOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<AmenitiesNode>;
  amenitiesesConnection: (
    args?: {
      where?: AmenitiesWhereInput;
      orderBy?: AmenitiesOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => AmenitiesConnection;
  booking: (where: BookingWhereUniqueInput) => Booking;
  bookings: (
    args?: {
      where?: BookingWhereInput;
      orderBy?: BookingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<BookingNode>;
  bookingsConnection: (
    args?: {
      where?: BookingWhereInput;
      orderBy?: BookingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => BookingConnection;
  city: (where: CityWhereUniqueInput) => City;
  cities: (
    args?: {
      where?: CityWhereInput;
      orderBy?: CityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<CityNode>;
  citiesConnection: (
    args?: {
      where?: CityWhereInput;
      orderBy?: CityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CityConnection;
  creditCardInformation: (
    where: CreditCardInformationWhereUniqueInput
  ) => CreditCardInformation;
  creditCardInformations: (
    args?: {
      where?: CreditCardInformationWhereInput;
      orderBy?: CreditCardInformationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<CreditCardInformationNode>;
  creditCardInformationsConnection: (
    args?: {
      where?: CreditCardInformationWhereInput;
      orderBy?: CreditCardInformationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CreditCardInformationConnection;
  experience: (where: ExperienceWhereUniqueInput) => Experience;
  experiences: (
    args?: {
      where?: ExperienceWhereInput;
      orderBy?: ExperienceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<ExperienceNode>;
  experiencesConnection: (
    args?: {
      where?: ExperienceWhereInput;
      orderBy?: ExperienceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ExperienceConnection;
  experienceCategory: (
    where: ExperienceCategoryWhereUniqueInput
  ) => ExperienceCategory;
  experienceCategories: (
    args?: {
      where?: ExperienceCategoryWhereInput;
      orderBy?: ExperienceCategoryOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<ExperienceCategoryNode>;
  experienceCategoriesConnection: (
    args?: {
      where?: ExperienceCategoryWhereInput;
      orderBy?: ExperienceCategoryOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ExperienceCategoryConnection;
  guestRequirements: (
    where: GuestRequirementsWhereUniqueInput
  ) => GuestRequirements;
  guestRequirementses: (
    args?: {
      where?: GuestRequirementsWhereInput;
      orderBy?: GuestRequirementsOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<GuestRequirementsNode>;
  guestRequirementsesConnection: (
    args?: {
      where?: GuestRequirementsWhereInput;
      orderBy?: GuestRequirementsOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => GuestRequirementsConnection;
  houseRules: (where: HouseRulesWhereUniqueInput) => HouseRules;
  houseRuleses: (
    args?: {
      where?: HouseRulesWhereInput;
      orderBy?: HouseRulesOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<HouseRulesNode>;
  houseRulesesConnection: (
    args?: {
      where?: HouseRulesWhereInput;
      orderBy?: HouseRulesOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => HouseRulesConnection;
  location: (where: LocationWhereUniqueInput) => Location;
  locations: (
    args?: {
      where?: LocationWhereInput;
      orderBy?: LocationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<LocationNode>;
  locationsConnection: (
    args?: {
      where?: LocationWhereInput;
      orderBy?: LocationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => LocationConnection;
  message: (where: MessageWhereUniqueInput) => Message;
  messages: (
    args?: {
      where?: MessageWhereInput;
      orderBy?: MessageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<MessageNode>;
  messagesConnection: (
    args?: {
      where?: MessageWhereInput;
      orderBy?: MessageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => MessageConnection;
  neighbourhood: (where: NeighbourhoodWhereUniqueInput) => Neighbourhood;
  neighbourhoods: (
    args?: {
      where?: NeighbourhoodWhereInput;
      orderBy?: NeighbourhoodOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<NeighbourhoodNode>;
  neighbourhoodsConnection: (
    args?: {
      where?: NeighbourhoodWhereInput;
      orderBy?: NeighbourhoodOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => NeighbourhoodConnection;
  notification: (where: NotificationWhereUniqueInput) => Notification;
  notifications: (
    args?: {
      where?: NotificationWhereInput;
      orderBy?: NotificationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<NotificationNode>;
  notificationsConnection: (
    args?: {
      where?: NotificationWhereInput;
      orderBy?: NotificationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => NotificationConnection;
  payment: (where: PaymentWhereUniqueInput) => Payment;
  payments: (
    args?: {
      where?: PaymentWhereInput;
      orderBy?: PaymentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<PaymentNode>;
  paymentsConnection: (
    args?: {
      where?: PaymentWhereInput;
      orderBy?: PaymentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => PaymentConnection;
  paymentAccount: (where: PaymentAccountWhereUniqueInput) => PaymentAccount;
  paymentAccounts: (
    args?: {
      where?: PaymentAccountWhereInput;
      orderBy?: PaymentAccountOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<PaymentAccountNode>;
  paymentAccountsConnection: (
    args?: {
      where?: PaymentAccountWhereInput;
      orderBy?: PaymentAccountOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => PaymentAccountConnection;
  paypalInformation: (
    where: PaypalInformationWhereUniqueInput
  ) => PaypalInformation;
  paypalInformations: (
    args?: {
      where?: PaypalInformationWhereInput;
      orderBy?: PaypalInformationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<PaypalInformationNode>;
  paypalInformationsConnection: (
    args?: {
      where?: PaypalInformationWhereInput;
      orderBy?: PaypalInformationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => PaypalInformationConnection;
  picture: (where: PictureWhereUniqueInput) => Picture;
  pictures: (
    args?: {
      where?: PictureWhereInput;
      orderBy?: PictureOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<PictureNode>;
  picturesConnection: (
    args?: {
      where?: PictureWhereInput;
      orderBy?: PictureOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => PictureConnection;
  place: (where: PlaceWhereUniqueInput) => Place;
  places: (
    args?: {
      where?: PlaceWhereInput;
      orderBy?: PlaceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<PlaceNode>;
  placesConnection: (
    args?: {
      where?: PlaceWhereInput;
      orderBy?: PlaceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => PlaceConnection;
  policies: (where: PoliciesWhereUniqueInput) => Policies;
  policieses: (
    args?: {
      where?: PoliciesWhereInput;
      orderBy?: PoliciesOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<PoliciesNode>;
  policiesesConnection: (
    args?: {
      where?: PoliciesWhereInput;
      orderBy?: PoliciesOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => PoliciesConnection;
  pricing: (where: PricingWhereUniqueInput) => Pricing;
  pricings: (
    args?: {
      where?: PricingWhereInput;
      orderBy?: PricingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<PricingNode>;
  pricingsConnection: (
    args?: {
      where?: PricingWhereInput;
      orderBy?: PricingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => PricingConnection;
  restaurant: (where: RestaurantWhereUniqueInput) => Restaurant;
  restaurants: (
    args?: {
      where?: RestaurantWhereInput;
      orderBy?: RestaurantOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<RestaurantNode>;
  restaurantsConnection: (
    args?: {
      where?: RestaurantWhereInput;
      orderBy?: RestaurantOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => RestaurantConnection;
  review: (where: ReviewWhereUniqueInput) => Review;
  reviews: (
    args?: {
      where?: ReviewWhereInput;
      orderBy?: ReviewOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<ReviewNode>;
  reviewsConnection: (
    args?: {
      where?: ReviewWhereInput;
      orderBy?: ReviewOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ReviewConnection;
  user: (where: UserWhereUniqueInput) => User;
  users: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<UserNode>;
  usersConnection: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UserConnection;
  views: (where: ViewsWhereUniqueInput) => Views;
  viewses: (
    args?: {
      where?: ViewsWhereInput;
      orderBy?: ViewsOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<ViewsNode>;
  viewsesConnection: (
    args?: {
      where?: ViewsWhereInput;
      orderBy?: ViewsOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ViewsConnection;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createAmenities: (data: AmenitiesCreateInput) => Amenities;
  updateAmenities: (
    args: { data: AmenitiesUpdateInput; where: AmenitiesWhereUniqueInput }
  ) => Amenities;
  updateManyAmenitieses: (
    args: { data: AmenitiesUpdateInput; where?: AmenitiesWhereInput }
  ) => BatchPayload;
  upsertAmenities: (
    args: {
      where: AmenitiesWhereUniqueInput;
      create: AmenitiesCreateInput;
      update: AmenitiesUpdateInput;
    }
  ) => Amenities;
  deleteAmenities: (where: AmenitiesWhereUniqueInput) => Amenities;
  deleteManyAmenitieses: (where?: AmenitiesWhereInput) => BatchPayload;
  createBooking: (data: BookingCreateInput) => Booking;
  updateBooking: (
    args: { data: BookingUpdateInput; where: BookingWhereUniqueInput }
  ) => Booking;
  updateManyBookings: (
    args: { data: BookingUpdateInput; where?: BookingWhereInput }
  ) => BatchPayload;
  upsertBooking: (
    args: {
      where: BookingWhereUniqueInput;
      create: BookingCreateInput;
      update: BookingUpdateInput;
    }
  ) => Booking;
  deleteBooking: (where: BookingWhereUniqueInput) => Booking;
  deleteManyBookings: (where?: BookingWhereInput) => BatchPayload;
  createCity: (data: CityCreateInput) => City;
  updateCity: (
    args: { data: CityUpdateInput; where: CityWhereUniqueInput }
  ) => City;
  updateManyCities: (
    args: { data: CityUpdateInput; where?: CityWhereInput }
  ) => BatchPayload;
  upsertCity: (
    args: {
      where: CityWhereUniqueInput;
      create: CityCreateInput;
      update: CityUpdateInput;
    }
  ) => City;
  deleteCity: (where: CityWhereUniqueInput) => City;
  deleteManyCities: (where?: CityWhereInput) => BatchPayload;
  createCreditCardInformation: (
    data: CreditCardInformationCreateInput
  ) => CreditCardInformation;
  updateCreditCardInformation: (
    args: {
      data: CreditCardInformationUpdateInput;
      where: CreditCardInformationWhereUniqueInput;
    }
  ) => CreditCardInformation;
  updateManyCreditCardInformations: (
    args: {
      data: CreditCardInformationUpdateInput;
      where?: CreditCardInformationWhereInput;
    }
  ) => BatchPayload;
  upsertCreditCardInformation: (
    args: {
      where: CreditCardInformationWhereUniqueInput;
      create: CreditCardInformationCreateInput;
      update: CreditCardInformationUpdateInput;
    }
  ) => CreditCardInformation;
  deleteCreditCardInformation: (
    where: CreditCardInformationWhereUniqueInput
  ) => CreditCardInformation;
  deleteManyCreditCardInformations: (
    where?: CreditCardInformationWhereInput
  ) => BatchPayload;
  createExperience: (data: ExperienceCreateInput) => Experience;
  updateExperience: (
    args: { data: ExperienceUpdateInput; where: ExperienceWhereUniqueInput }
  ) => Experience;
  updateManyExperiences: (
    args: { data: ExperienceUpdateInput; where?: ExperienceWhereInput }
  ) => BatchPayload;
  upsertExperience: (
    args: {
      where: ExperienceWhereUniqueInput;
      create: ExperienceCreateInput;
      update: ExperienceUpdateInput;
    }
  ) => Experience;
  deleteExperience: (where: ExperienceWhereUniqueInput) => Experience;
  deleteManyExperiences: (where?: ExperienceWhereInput) => BatchPayload;
  createExperienceCategory: (
    data: ExperienceCategoryCreateInput
  ) => ExperienceCategory;
  updateExperienceCategory: (
    args: {
      data: ExperienceCategoryUpdateInput;
      where: ExperienceCategoryWhereUniqueInput;
    }
  ) => ExperienceCategory;
  updateManyExperienceCategories: (
    args: {
      data: ExperienceCategoryUpdateInput;
      where?: ExperienceCategoryWhereInput;
    }
  ) => BatchPayload;
  upsertExperienceCategory: (
    args: {
      where: ExperienceCategoryWhereUniqueInput;
      create: ExperienceCategoryCreateInput;
      update: ExperienceCategoryUpdateInput;
    }
  ) => ExperienceCategory;
  deleteExperienceCategory: (
    where: ExperienceCategoryWhereUniqueInput
  ) => ExperienceCategory;
  deleteManyExperienceCategories: (
    where?: ExperienceCategoryWhereInput
  ) => BatchPayload;
  createGuestRequirements: (
    data: GuestRequirementsCreateInput
  ) => GuestRequirements;
  updateGuestRequirements: (
    args: {
      data: GuestRequirementsUpdateInput;
      where: GuestRequirementsWhereUniqueInput;
    }
  ) => GuestRequirements;
  updateManyGuestRequirementses: (
    args: {
      data: GuestRequirementsUpdateInput;
      where?: GuestRequirementsWhereInput;
    }
  ) => BatchPayload;
  upsertGuestRequirements: (
    args: {
      where: GuestRequirementsWhereUniqueInput;
      create: GuestRequirementsCreateInput;
      update: GuestRequirementsUpdateInput;
    }
  ) => GuestRequirements;
  deleteGuestRequirements: (
    where: GuestRequirementsWhereUniqueInput
  ) => GuestRequirements;
  deleteManyGuestRequirementses: (
    where?: GuestRequirementsWhereInput
  ) => BatchPayload;
  createHouseRules: (data: HouseRulesCreateInput) => HouseRules;
  updateHouseRules: (
    args: { data: HouseRulesUpdateInput; where: HouseRulesWhereUniqueInput }
  ) => HouseRules;
  updateManyHouseRuleses: (
    args: { data: HouseRulesUpdateInput; where?: HouseRulesWhereInput }
  ) => BatchPayload;
  upsertHouseRules: (
    args: {
      where: HouseRulesWhereUniqueInput;
      create: HouseRulesCreateInput;
      update: HouseRulesUpdateInput;
    }
  ) => HouseRules;
  deleteHouseRules: (where: HouseRulesWhereUniqueInput) => HouseRules;
  deleteManyHouseRuleses: (where?: HouseRulesWhereInput) => BatchPayload;
  createLocation: (data: LocationCreateInput) => Location;
  updateLocation: (
    args: { data: LocationUpdateInput; where: LocationWhereUniqueInput }
  ) => Location;
  updateManyLocations: (
    args: { data: LocationUpdateInput; where?: LocationWhereInput }
  ) => BatchPayload;
  upsertLocation: (
    args: {
      where: LocationWhereUniqueInput;
      create: LocationCreateInput;
      update: LocationUpdateInput;
    }
  ) => Location;
  deleteLocation: (where: LocationWhereUniqueInput) => Location;
  deleteManyLocations: (where?: LocationWhereInput) => BatchPayload;
  createMessage: (data: MessageCreateInput) => Message;
  updateMessage: (
    args: { data: MessageUpdateInput; where: MessageWhereUniqueInput }
  ) => Message;
  updateManyMessages: (
    args: { data: MessageUpdateInput; where?: MessageWhereInput }
  ) => BatchPayload;
  upsertMessage: (
    args: {
      where: MessageWhereUniqueInput;
      create: MessageCreateInput;
      update: MessageUpdateInput;
    }
  ) => Message;
  deleteMessage: (where: MessageWhereUniqueInput) => Message;
  deleteManyMessages: (where?: MessageWhereInput) => BatchPayload;
  createNeighbourhood: (data: NeighbourhoodCreateInput) => Neighbourhood;
  updateNeighbourhood: (
    args: {
      data: NeighbourhoodUpdateInput;
      where: NeighbourhoodWhereUniqueInput;
    }
  ) => Neighbourhood;
  updateManyNeighbourhoods: (
    args: { data: NeighbourhoodUpdateInput; where?: NeighbourhoodWhereInput }
  ) => BatchPayload;
  upsertNeighbourhood: (
    args: {
      where: NeighbourhoodWhereUniqueInput;
      create: NeighbourhoodCreateInput;
      update: NeighbourhoodUpdateInput;
    }
  ) => Neighbourhood;
  deleteNeighbourhood: (where: NeighbourhoodWhereUniqueInput) => Neighbourhood;
  deleteManyNeighbourhoods: (where?: NeighbourhoodWhereInput) => BatchPayload;
  createNotification: (data: NotificationCreateInput) => Notification;
  updateNotification: (
    args: { data: NotificationUpdateInput; where: NotificationWhereUniqueInput }
  ) => Notification;
  updateManyNotifications: (
    args: { data: NotificationUpdateInput; where?: NotificationWhereInput }
  ) => BatchPayload;
  upsertNotification: (
    args: {
      where: NotificationWhereUniqueInput;
      create: NotificationCreateInput;
      update: NotificationUpdateInput;
    }
  ) => Notification;
  deleteNotification: (where: NotificationWhereUniqueInput) => Notification;
  deleteManyNotifications: (where?: NotificationWhereInput) => BatchPayload;
  createPayment: (data: PaymentCreateInput) => Payment;
  updatePayment: (
    args: { data: PaymentUpdateInput; where: PaymentWhereUniqueInput }
  ) => Payment;
  updateManyPayments: (
    args: { data: PaymentUpdateInput; where?: PaymentWhereInput }
  ) => BatchPayload;
  upsertPayment: (
    args: {
      where: PaymentWhereUniqueInput;
      create: PaymentCreateInput;
      update: PaymentUpdateInput;
    }
  ) => Payment;
  deletePayment: (where: PaymentWhereUniqueInput) => Payment;
  deleteManyPayments: (where?: PaymentWhereInput) => BatchPayload;
  createPaymentAccount: (data: PaymentAccountCreateInput) => PaymentAccount;
  updatePaymentAccount: (
    args: {
      data: PaymentAccountUpdateInput;
      where: PaymentAccountWhereUniqueInput;
    }
  ) => PaymentAccount;
  updateManyPaymentAccounts: (
    args: { data: PaymentAccountUpdateInput; where?: PaymentAccountWhereInput }
  ) => BatchPayload;
  upsertPaymentAccount: (
    args: {
      where: PaymentAccountWhereUniqueInput;
      create: PaymentAccountCreateInput;
      update: PaymentAccountUpdateInput;
    }
  ) => PaymentAccount;
  deletePaymentAccount: (
    where: PaymentAccountWhereUniqueInput
  ) => PaymentAccount;
  deleteManyPaymentAccounts: (where?: PaymentAccountWhereInput) => BatchPayload;
  createPaypalInformation: (
    data: PaypalInformationCreateInput
  ) => PaypalInformation;
  updatePaypalInformation: (
    args: {
      data: PaypalInformationUpdateInput;
      where: PaypalInformationWhereUniqueInput;
    }
  ) => PaypalInformation;
  updateManyPaypalInformations: (
    args: {
      data: PaypalInformationUpdateInput;
      where?: PaypalInformationWhereInput;
    }
  ) => BatchPayload;
  upsertPaypalInformation: (
    args: {
      where: PaypalInformationWhereUniqueInput;
      create: PaypalInformationCreateInput;
      update: PaypalInformationUpdateInput;
    }
  ) => PaypalInformation;
  deletePaypalInformation: (
    where: PaypalInformationWhereUniqueInput
  ) => PaypalInformation;
  deleteManyPaypalInformations: (
    where?: PaypalInformationWhereInput
  ) => BatchPayload;
  createPicture: (data: PictureCreateInput) => Picture;
  updatePicture: (
    args: { data: PictureUpdateInput; where: PictureWhereUniqueInput }
  ) => Picture;
  updateManyPictures: (
    args: { data: PictureUpdateInput; where?: PictureWhereInput }
  ) => BatchPayload;
  upsertPicture: (
    args: {
      where: PictureWhereUniqueInput;
      create: PictureCreateInput;
      update: PictureUpdateInput;
    }
  ) => Picture;
  deletePicture: (where: PictureWhereUniqueInput) => Picture;
  deleteManyPictures: (where?: PictureWhereInput) => BatchPayload;
  createPlace: (data: PlaceCreateInput) => Place;
  updatePlace: (
    args: { data: PlaceUpdateInput; where: PlaceWhereUniqueInput }
  ) => Place;
  updateManyPlaces: (
    args: { data: PlaceUpdateInput; where?: PlaceWhereInput }
  ) => BatchPayload;
  upsertPlace: (
    args: {
      where: PlaceWhereUniqueInput;
      create: PlaceCreateInput;
      update: PlaceUpdateInput;
    }
  ) => Place;
  deletePlace: (where: PlaceWhereUniqueInput) => Place;
  deleteManyPlaces: (where?: PlaceWhereInput) => BatchPayload;
  createPolicies: (data: PoliciesCreateInput) => Policies;
  updatePolicies: (
    args: { data: PoliciesUpdateInput; where: PoliciesWhereUniqueInput }
  ) => Policies;
  updateManyPolicieses: (
    args: { data: PoliciesUpdateInput; where?: PoliciesWhereInput }
  ) => BatchPayload;
  upsertPolicies: (
    args: {
      where: PoliciesWhereUniqueInput;
      create: PoliciesCreateInput;
      update: PoliciesUpdateInput;
    }
  ) => Policies;
  deletePolicies: (where: PoliciesWhereUniqueInput) => Policies;
  deleteManyPolicieses: (where?: PoliciesWhereInput) => BatchPayload;
  createPricing: (data: PricingCreateInput) => Pricing;
  updatePricing: (
    args: { data: PricingUpdateInput; where: PricingWhereUniqueInput }
  ) => Pricing;
  updateManyPricings: (
    args: { data: PricingUpdateInput; where?: PricingWhereInput }
  ) => BatchPayload;
  upsertPricing: (
    args: {
      where: PricingWhereUniqueInput;
      create: PricingCreateInput;
      update: PricingUpdateInput;
    }
  ) => Pricing;
  deletePricing: (where: PricingWhereUniqueInput) => Pricing;
  deleteManyPricings: (where?: PricingWhereInput) => BatchPayload;
  createRestaurant: (data: RestaurantCreateInput) => Restaurant;
  updateRestaurant: (
    args: { data: RestaurantUpdateInput; where: RestaurantWhereUniqueInput }
  ) => Restaurant;
  updateManyRestaurants: (
    args: { data: RestaurantUpdateInput; where?: RestaurantWhereInput }
  ) => BatchPayload;
  upsertRestaurant: (
    args: {
      where: RestaurantWhereUniqueInput;
      create: RestaurantCreateInput;
      update: RestaurantUpdateInput;
    }
  ) => Restaurant;
  deleteRestaurant: (where: RestaurantWhereUniqueInput) => Restaurant;
  deleteManyRestaurants: (where?: RestaurantWhereInput) => BatchPayload;
  createReview: (data: ReviewCreateInput) => Review;
  updateReview: (
    args: { data: ReviewUpdateInput; where: ReviewWhereUniqueInput }
  ) => Review;
  updateManyReviews: (
    args: { data: ReviewUpdateInput; where?: ReviewWhereInput }
  ) => BatchPayload;
  upsertReview: (
    args: {
      where: ReviewWhereUniqueInput;
      create: ReviewCreateInput;
      update: ReviewUpdateInput;
    }
  ) => Review;
  deleteReview: (where: ReviewWhereUniqueInput) => Review;
  deleteManyReviews: (where?: ReviewWhereInput) => BatchPayload;
  createUser: (data: UserCreateInput) => User;
  updateUser: (
    args: { data: UserUpdateInput; where: UserWhereUniqueInput }
  ) => User;
  updateManyUsers: (
    args: { data: UserUpdateInput; where?: UserWhereInput }
  ) => BatchPayload;
  upsertUser: (
    args: {
      where: UserWhereUniqueInput;
      create: UserCreateInput;
      update: UserUpdateInput;
    }
  ) => User;
  deleteUser: (where: UserWhereUniqueInput) => User;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayload;
  createViews: (data: ViewsCreateInput) => Views;
  updateViews: (
    args: { data: ViewsUpdateInput; where: ViewsWhereUniqueInput }
  ) => Views;
  updateManyViewses: (
    args: { data: ViewsUpdateInput; where?: ViewsWhereInput }
  ) => BatchPayload;
  upsertViews: (
    args: {
      where: ViewsWhereUniqueInput;
      create: ViewsCreateInput;
      update: ViewsUpdateInput;
    }
  ) => Views;
  deleteViews: (where: ViewsWhereUniqueInput) => Views;
  deleteManyViewses: (where?: ViewsWhereInput) => BatchPayload;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  amenities: (
    where?: AmenitiesSubscriptionWhereInput
  ) => AmenitiesSubscriptionPayloadSubscription;
  booking: (
    where?: BookingSubscriptionWhereInput
  ) => BookingSubscriptionPayloadSubscription;
  city: (
    where?: CitySubscriptionWhereInput
  ) => CitySubscriptionPayloadSubscription;
  creditCardInformation: (
    where?: CreditCardInformationSubscriptionWhereInput
  ) => CreditCardInformationSubscriptionPayloadSubscription;
  experience: (
    where?: ExperienceSubscriptionWhereInput
  ) => ExperienceSubscriptionPayloadSubscription;
  experienceCategory: (
    where?: ExperienceCategorySubscriptionWhereInput
  ) => ExperienceCategorySubscriptionPayloadSubscription;
  guestRequirements: (
    where?: GuestRequirementsSubscriptionWhereInput
  ) => GuestRequirementsSubscriptionPayloadSubscription;
  houseRules: (
    where?: HouseRulesSubscriptionWhereInput
  ) => HouseRulesSubscriptionPayloadSubscription;
  location: (
    where?: LocationSubscriptionWhereInput
  ) => LocationSubscriptionPayloadSubscription;
  message: (
    where?: MessageSubscriptionWhereInput
  ) => MessageSubscriptionPayloadSubscription;
  neighbourhood: (
    where?: NeighbourhoodSubscriptionWhereInput
  ) => NeighbourhoodSubscriptionPayloadSubscription;
  notification: (
    where?: NotificationSubscriptionWhereInput
  ) => NotificationSubscriptionPayloadSubscription;
  payment: (
    where?: PaymentSubscriptionWhereInput
  ) => PaymentSubscriptionPayloadSubscription;
  paymentAccount: (
    where?: PaymentAccountSubscriptionWhereInput
  ) => PaymentAccountSubscriptionPayloadSubscription;
  paypalInformation: (
    where?: PaypalInformationSubscriptionWhereInput
  ) => PaypalInformationSubscriptionPayloadSubscription;
  picture: (
    where?: PictureSubscriptionWhereInput
  ) => PictureSubscriptionPayloadSubscription;
  place: (
    where?: PlaceSubscriptionWhereInput
  ) => PlaceSubscriptionPayloadSubscription;
  policies: (
    where?: PoliciesSubscriptionWhereInput
  ) => PoliciesSubscriptionPayloadSubscription;
  pricing: (
    where?: PricingSubscriptionWhereInput
  ) => PricingSubscriptionPayloadSubscription;
  restaurant: (
    where?: RestaurantSubscriptionWhereInput
  ) => RestaurantSubscriptionPayloadSubscription;
  review: (
    where?: ReviewSubscriptionWhereInput
  ) => ReviewSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
  views: (
    where?: ViewsSubscriptionWhereInput
  ) => ViewsSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type AmenitiesOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "elevator_ASC"
  | "elevator_DESC"
  | "petsAllowed_ASC"
  | "petsAllowed_DESC"
  | "internet_ASC"
  | "internet_DESC"
  | "kitchen_ASC"
  | "kitchen_DESC"
  | "wirelessInternet_ASC"
  | "wirelessInternet_DESC"
  | "familyKidFriendly_ASC"
  | "familyKidFriendly_DESC"
  | "freeParkingOnPremises_ASC"
  | "freeParkingOnPremises_DESC"
  | "hotTub_ASC"
  | "hotTub_DESC"
  | "pool_ASC"
  | "pool_DESC"
  | "smokingAllowed_ASC"
  | "smokingAllowed_DESC"
  | "wheelchairAccessible_ASC"
  | "wheelchairAccessible_DESC"
  | "breakfast_ASC"
  | "breakfast_DESC"
  | "cableTv_ASC"
  | "cableTv_DESC"
  | "suitableForEvents_ASC"
  | "suitableForEvents_DESC"
  | "dryer_ASC"
  | "dryer_DESC"
  | "washer_ASC"
  | "washer_DESC"
  | "indoorFireplace_ASC"
  | "indoorFireplace_DESC"
  | "tv_ASC"
  | "tv_DESC"
  | "heating_ASC"
  | "heating_DESC"
  | "hangers_ASC"
  | "hangers_DESC"
  | "iron_ASC"
  | "iron_DESC"
  | "hairDryer_ASC"
  | "hairDryer_DESC"
  | "doorman_ASC"
  | "doorman_DESC"
  | "paidParkingOffPremises_ASC"
  | "paidParkingOffPremises_DESC"
  | "freeParkingOnStreet_ASC"
  | "freeParkingOnStreet_DESC"
  | "gym_ASC"
  | "gym_DESC"
  | "airConditioning_ASC"
  | "airConditioning_DESC"
  | "shampoo_ASC"
  | "shampoo_DESC"
  | "essentials_ASC"
  | "essentials_DESC"
  | "laptopFriendlyWorkspace_ASC"
  | "laptopFriendlyWorkspace_DESC"
  | "privateEntrance_ASC"
  | "privateEntrance_DESC"
  | "buzzerWirelessIntercom_ASC"
  | "buzzerWirelessIntercom_DESC"
  | "babyBath_ASC"
  | "babyBath_DESC"
  | "babyMonitor_ASC"
  | "babyMonitor_DESC"
  | "babysitterRecommendations_ASC"
  | "babysitterRecommendations_DESC"
  | "bathtub_ASC"
  | "bathtub_DESC"
  | "changingTable_ASC"
  | "changingTable_DESC"
  | "childrensBooksAndToys_ASC"
  | "childrensBooksAndToys_DESC"
  | "childrensDinnerware_ASC"
  | "childrensDinnerware_DESC"
  | "crib_ASC"
  | "crib_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type NOTIFICATION_TYPE =
  | "OFFER"
  | "INSTANT_BOOK"
  | "RESPONSIVENESS"
  | "NEW_AMENITIES"
  | "HOUSE_RULES";

export type ExperienceOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "pricePerPerson_ASC"
  | "pricePerPerson_DESC"
  | "popularity_ASC"
  | "popularity_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ViewsOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "lastWeek_ASC"
  | "lastWeek_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type NotificationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "type_ASC"
  | "type_DESC"
  | "link_ASC"
  | "link_DESC"
  | "readDate_ASC"
  | "readDate_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PLACE_SIZES =
  | "ENTIRE_HOUSE"
  | "ENTIRE_APARTMENT"
  | "ENTIRE_EARTH_HOUSE"
  | "ENTIRE_CABIN"
  | "ENTIRE_VILLA"
  | "ENTIRE_PLACE"
  | "ENTIRE_BOAT"
  | "PRIVATE_ROOM";

export type MessageOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "deliveredAt_ASC"
  | "deliveredAt_DESC"
  | "readAt_ASC"
  | "readAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PricingOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "monthlyDiscount_ASC"
  | "monthlyDiscount_DESC"
  | "weeklyDiscount_ASC"
  | "weeklyDiscount_DESC"
  | "perNight_ASC"
  | "perNight_DESC"
  | "smartPricing_ASC"
  | "smartPricing_DESC"
  | "basePrice_ASC"
  | "basePrice_DESC"
  | "averageWeekly_ASC"
  | "averageWeekly_DESC"
  | "averageMonthly_ASC"
  | "averageMonthly_DESC"
  | "cleaningFee_ASC"
  | "cleaningFee_DESC"
  | "securityDeposit_ASC"
  | "securityDeposit_DESC"
  | "extraGuests_ASC"
  | "extraGuests_DESC"
  | "weekendPricing_ASC"
  | "weekendPricing_DESC"
  | "currency_ASC"
  | "currency_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PaymentAccountOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "type_ASC"
  | "type_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PaypalInformationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "email_ASC"
  | "email_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PaymentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "serviceFee_ASC"
  | "serviceFee_DESC"
  | "placePrice_ASC"
  | "placePrice_DESC"
  | "totalPrice_ASC"
  | "totalPrice_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type GuestRequirementsOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "govIssuedId_ASC"
  | "govIssuedId_DESC"
  | "recommendationsFromOtherHosts_ASC"
  | "recommendationsFromOtherHosts_DESC"
  | "guestTripInformation_ASC"
  | "guestTripInformation_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type BookingOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "startDate_ASC"
  | "startDate_DESC"
  | "endDate_ASC"
  | "endDate_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CreditCardInformationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "cardNumber_ASC"
  | "cardNumber_DESC"
  | "expiresOnMonth_ASC"
  | "expiresOnMonth_DESC"
  | "expiresOnYear_ASC"
  | "expiresOnYear_DESC"
  | "securityCode_ASC"
  | "securityCode_DESC"
  | "firstName_ASC"
  | "firstName_DESC"
  | "lastName_ASC"
  | "lastName_DESC"
  | "postalCode_ASC"
  | "postalCode_DESC"
  | "country_ASC"
  | "country_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PictureOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "url_ASC"
  | "url_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type NeighbourhoodOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "slug_ASC"
  | "slug_DESC"
  | "featured_ASC"
  | "featured_DESC"
  | "popularity_ASC"
  | "popularity_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type RestaurantOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "title_ASC"
  | "title_DESC"
  | "avgPricePerPerson_ASC"
  | "avgPricePerPerson_DESC"
  | "isCurated_ASC"
  | "isCurated_DESC"
  | "slug_ASC"
  | "slug_DESC"
  | "popularity_ASC"
  | "popularity_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PAYMENT_PROVIDER = "PAYPAL" | "CREDIT_CARD";

export type HouseRulesOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "suitableForChildren_ASC"
  | "suitableForChildren_DESC"
  | "suitableForInfants_ASC"
  | "suitableForInfants_DESC"
  | "petsAllowed_ASC"
  | "petsAllowed_DESC"
  | "smokingAllowed_ASC"
  | "smokingAllowed_DESC"
  | "partiesAndEventsAllowed_ASC"
  | "partiesAndEventsAllowed_DESC"
  | "additionalRules_ASC"
  | "additionalRules_DESC";

export type CURRENCY = "CAD" | "CHF" | "EUR" | "JPY" | "USD" | "ZAR";

export type ReviewOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "text_ASC"
  | "text_DESC"
  | "stars_ASC"
  | "stars_DESC"
  | "accuracy_ASC"
  | "accuracy_DESC"
  | "location_ASC"
  | "location_DESC"
  | "checkIn_ASC"
  | "checkIn_DESC"
  | "value_ASC"
  | "value_DESC"
  | "cleanliness_ASC"
  | "cleanliness_DESC"
  | "communication_ASC"
  | "communication_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PlaceOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "size_ASC"
  | "size_DESC"
  | "shortDescription_ASC"
  | "shortDescription_DESC"
  | "description_ASC"
  | "description_DESC"
  | "slug_ASC"
  | "slug_DESC"
  | "maxGuests_ASC"
  | "maxGuests_DESC"
  | "numBedrooms_ASC"
  | "numBedrooms_DESC"
  | "numBeds_ASC"
  | "numBeds_DESC"
  | "numBaths_ASC"
  | "numBaths_DESC"
  | "popularity_ASC"
  | "popularity_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type LocationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "lat_ASC"
  | "lat_DESC"
  | "lng_ASC"
  | "lng_DESC"
  | "address_ASC"
  | "address_DESC"
  | "directions_ASC"
  | "directions_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ExperienceCategoryOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "mainColor_ASC"
  | "mainColor_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PoliciesOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "checkInStartTime_ASC"
  | "checkInStartTime_DESC"
  | "checkInEndTime_ASC"
  | "checkInEndTime_DESC"
  | "checkoutTime_ASC"
  | "checkoutTime_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "firstName_ASC"
  | "firstName_DESC"
  | "lastName_ASC"
  | "lastName_DESC"
  | "email_ASC"
  | "email_DESC"
  | "password_ASC"
  | "password_DESC"
  | "phone_ASC"
  | "phone_DESC"
  | "responseRate_ASC"
  | "responseRate_DESC"
  | "responseTime_ASC"
  | "responseTime_DESC"
  | "isSuperHost_ASC"
  | "isSuperHost_DESC";

export type CityOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export interface PictureUpdateDataInput {
  url?: String;
}

export type AmenitiesWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface LocationUpdateOneWithoutUserInput {
  create?: LocationCreateWithoutUserInput;
  update?: LocationUpdateWithoutUserDataInput;
  upsert?: LocationUpsertWithoutUserInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: LocationWhereUniqueInput;
}

export interface PricingWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  place?: PlaceWhereInput;
  monthlyDiscount?: Int;
  monthlyDiscount_not?: Int;
  monthlyDiscount_in?: Int[] | Int;
  monthlyDiscount_not_in?: Int[] | Int;
  monthlyDiscount_lt?: Int;
  monthlyDiscount_lte?: Int;
  monthlyDiscount_gt?: Int;
  monthlyDiscount_gte?: Int;
  weeklyDiscount?: Int;
  weeklyDiscount_not?: Int;
  weeklyDiscount_in?: Int[] | Int;
  weeklyDiscount_not_in?: Int[] | Int;
  weeklyDiscount_lt?: Int;
  weeklyDiscount_lte?: Int;
  weeklyDiscount_gt?: Int;
  weeklyDiscount_gte?: Int;
  perNight?: Int;
  perNight_not?: Int;
  perNight_in?: Int[] | Int;
  perNight_not_in?: Int[] | Int;
  perNight_lt?: Int;
  perNight_lte?: Int;
  perNight_gt?: Int;
  perNight_gte?: Int;
  smartPricing?: Boolean;
  smartPricing_not?: Boolean;
  basePrice?: Int;
  basePrice_not?: Int;
  basePrice_in?: Int[] | Int;
  basePrice_not_in?: Int[] | Int;
  basePrice_lt?: Int;
  basePrice_lte?: Int;
  basePrice_gt?: Int;
  basePrice_gte?: Int;
  averageWeekly?: Int;
  averageWeekly_not?: Int;
  averageWeekly_in?: Int[] | Int;
  averageWeekly_not_in?: Int[] | Int;
  averageWeekly_lt?: Int;
  averageWeekly_lte?: Int;
  averageWeekly_gt?: Int;
  averageWeekly_gte?: Int;
  averageMonthly?: Int;
  averageMonthly_not?: Int;
  averageMonthly_in?: Int[] | Int;
  averageMonthly_not_in?: Int[] | Int;
  averageMonthly_lt?: Int;
  averageMonthly_lte?: Int;
  averageMonthly_gt?: Int;
  averageMonthly_gte?: Int;
  cleaningFee?: Int;
  cleaningFee_not?: Int;
  cleaningFee_in?: Int[] | Int;
  cleaningFee_not_in?: Int[] | Int;
  cleaningFee_lt?: Int;
  cleaningFee_lte?: Int;
  cleaningFee_gt?: Int;
  cleaningFee_gte?: Int;
  securityDeposit?: Int;
  securityDeposit_not?: Int;
  securityDeposit_in?: Int[] | Int;
  securityDeposit_not_in?: Int[] | Int;
  securityDeposit_lt?: Int;
  securityDeposit_lte?: Int;
  securityDeposit_gt?: Int;
  securityDeposit_gte?: Int;
  extraGuests?: Int;
  extraGuests_not?: Int;
  extraGuests_in?: Int[] | Int;
  extraGuests_not_in?: Int[] | Int;
  extraGuests_lt?: Int;
  extraGuests_lte?: Int;
  extraGuests_gt?: Int;
  extraGuests_gte?: Int;
  weekendPricing?: Int;
  weekendPricing_not?: Int;
  weekendPricing_in?: Int[] | Int;
  weekendPricing_not_in?: Int[] | Int;
  weekendPricing_lt?: Int;
  weekendPricing_lte?: Int;
  weekendPricing_gt?: Int;
  weekendPricing_gte?: Int;
  currency?: CURRENCY;
  currency_not?: CURRENCY;
  currency_in?: CURRENCY[] | CURRENCY;
  currency_not_in?: CURRENCY[] | CURRENCY;
  AND?: PricingWhereInput[] | PricingWhereInput;
  OR?: PricingWhereInput[] | PricingWhereInput;
  NOT?: PricingWhereInput[] | PricingWhereInput;
}

export interface LocationUpdateWithoutUserDataInput {
  lat?: Float;
  lng?: Float;
  neighbourHood?: NeighbourhoodUpdateOneWithoutLocationsInput;
  place?: PlaceUpdateOneWithoutLocationInput;
  address?: String;
  directions?: String;
  experience?: ExperienceUpdateOneWithoutLocationInput;
  restaurant?: RestaurantUpdateOneWithoutLocationInput;
}

export interface ViewsWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  lastWeek?: Int;
  lastWeek_not?: Int;
  lastWeek_in?: Int[] | Int;
  lastWeek_not_in?: Int[] | Int;
  lastWeek_lt?: Int;
  lastWeek_lte?: Int;
  lastWeek_gt?: Int;
  lastWeek_gte?: Int;
  place?: PlaceWhereInput;
  AND?: ViewsWhereInput[] | ViewsWhereInput;
  OR?: ViewsWhereInput[] | ViewsWhereInput;
  NOT?: ViewsWhereInput[] | ViewsWhereInput;
}

export interface PlaceUpdateOneWithoutLocationInput {
  create?: PlaceCreateWithoutLocationInput;
  update?: PlaceUpdateWithoutLocationDataInput;
  upsert?: PlaceUpsertWithoutLocationInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: PlaceWhereUniqueInput;
}

export interface PoliciesWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  checkInStartTime?: Float;
  checkInStartTime_not?: Float;
  checkInStartTime_in?: Float[] | Float;
  checkInStartTime_not_in?: Float[] | Float;
  checkInStartTime_lt?: Float;
  checkInStartTime_lte?: Float;
  checkInStartTime_gt?: Float;
  checkInStartTime_gte?: Float;
  checkInEndTime?: Float;
  checkInEndTime_not?: Float;
  checkInEndTime_in?: Float[] | Float;
  checkInEndTime_not_in?: Float[] | Float;
  checkInEndTime_lt?: Float;
  checkInEndTime_lte?: Float;
  checkInEndTime_gt?: Float;
  checkInEndTime_gte?: Float;
  checkoutTime?: Float;
  checkoutTime_not?: Float;
  checkoutTime_in?: Float[] | Float;
  checkoutTime_not_in?: Float[] | Float;
  checkoutTime_lt?: Float;
  checkoutTime_lte?: Float;
  checkoutTime_gt?: Float;
  checkoutTime_gte?: Float;
  place?: PlaceWhereInput;
  AND?: PoliciesWhereInput[] | PoliciesWhereInput;
  OR?: PoliciesWhereInput[] | PoliciesWhereInput;
  NOT?: PoliciesWhereInput[] | PoliciesWhereInput;
}

export interface PlaceUpdateWithoutLocationDataInput {
  name?: String;
  size?: PLACE_SIZES;
  shortDescription?: String;
  description?: String;
  slug?: String;
  maxGuests?: Int;
  numBedrooms?: Int;
  numBeds?: Int;
  numBaths?: Int;
  reviews?: ReviewUpdateManyWithoutPlaceInput;
  amenities?: AmenitiesUpdateOneRequiredWithoutPlaceInput;
  host?: UserUpdateOneRequiredWithoutOwnedPlacesInput;
  pricing?: PricingUpdateOneRequiredWithoutPlaceInput;
  views?: ViewsUpdateOneRequiredWithoutPlaceInput;
  guestRequirements?: GuestRequirementsUpdateOneWithoutPlaceInput;
  policies?: PoliciesUpdateOneWithoutPlaceInput;
  houseRules?: HouseRulesUpdateOneInput;
  bookings?: BookingUpdateManyWithoutPlaceInput;
  pictures?: PictureUpdateManyInput;
  popularity?: Int;
}

export interface MessageWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  from?: UserWhereInput;
  to?: UserWhereInput;
  deliveredAt?: DateTimeInput;
  deliveredAt_not?: DateTimeInput;
  deliveredAt_in?: DateTimeInput[] | DateTimeInput;
  deliveredAt_not_in?: DateTimeInput[] | DateTimeInput;
  deliveredAt_lt?: DateTimeInput;
  deliveredAt_lte?: DateTimeInput;
  deliveredAt_gt?: DateTimeInput;
  deliveredAt_gte?: DateTimeInput;
  readAt?: DateTimeInput;
  readAt_not?: DateTimeInput;
  readAt_in?: DateTimeInput[] | DateTimeInput;
  readAt_not_in?: DateTimeInput[] | DateTimeInput;
  readAt_lt?: DateTimeInput;
  readAt_lte?: DateTimeInput;
  readAt_gt?: DateTimeInput;
  readAt_gte?: DateTimeInput;
  AND?: MessageWhereInput[] | MessageWhereInput;
  OR?: MessageWhereInput[] | MessageWhereInput;
  NOT?: MessageWhereInput[] | MessageWhereInput;
}

export interface UserCreateWithoutReceivedMessagesInput {
  firstName: String;
  lastName: String;
  email: String;
  password: String;
  phone: String;
  responseRate?: Float;
  responseTime?: Int;
  isSuperHost?: Boolean;
  ownedPlaces?: PlaceCreateManyWithoutHostInput;
  location?: LocationCreateOneWithoutUserInput;
  bookings?: BookingCreateManyWithoutBookeeInput;
  paymentAccount?: PaymentAccountCreateManyWithoutUserInput;
  sentMessages?: MessageCreateManyWithoutFromInput;
  notifications?: NotificationCreateManyWithoutUserInput;
  profilePicture?: PictureCreateOneInput;
  hostingExperiences?: ExperienceCreateManyWithoutHostInput;
}

export interface PaymentAccountUpsertWithoutCreditcardInput {
  update: PaymentAccountUpdateWithoutCreditcardDataInput;
  create: PaymentAccountCreateWithoutCreditcardInput;
}

export interface NotificationCreateManyWithoutUserInput {
  create?:
    | NotificationCreateWithoutUserInput[]
    | NotificationCreateWithoutUserInput;
  connect?: NotificationWhereUniqueInput[] | NotificationWhereUniqueInput;
}

export interface ViewsUpdateOneRequiredWithoutPlaceInput {
  create?: ViewsCreateWithoutPlaceInput;
  update?: ViewsUpdateWithoutPlaceDataInput;
  upsert?: ViewsUpsertWithoutPlaceInput;
  connect?: ViewsWhereUniqueInput;
}

export interface NotificationCreateWithoutUserInput {
  type?: NOTIFICATION_TYPE;
  link: String;
  readDate: DateTimeInput;
}

export interface CreditCardInformationWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  cardNumber?: String;
  cardNumber_not?: String;
  cardNumber_in?: String[] | String;
  cardNumber_not_in?: String[] | String;
  cardNumber_lt?: String;
  cardNumber_lte?: String;
  cardNumber_gt?: String;
  cardNumber_gte?: String;
  cardNumber_contains?: String;
  cardNumber_not_contains?: String;
  cardNumber_starts_with?: String;
  cardNumber_not_starts_with?: String;
  cardNumber_ends_with?: String;
  cardNumber_not_ends_with?: String;
  expiresOnMonth?: Int;
  expiresOnMonth_not?: Int;
  expiresOnMonth_in?: Int[] | Int;
  expiresOnMonth_not_in?: Int[] | Int;
  expiresOnMonth_lt?: Int;
  expiresOnMonth_lte?: Int;
  expiresOnMonth_gt?: Int;
  expiresOnMonth_gte?: Int;
  expiresOnYear?: Int;
  expiresOnYear_not?: Int;
  expiresOnYear_in?: Int[] | Int;
  expiresOnYear_not_in?: Int[] | Int;
  expiresOnYear_lt?: Int;
  expiresOnYear_lte?: Int;
  expiresOnYear_gt?: Int;
  expiresOnYear_gte?: Int;
  securityCode?: String;
  securityCode_not?: String;
  securityCode_in?: String[] | String;
  securityCode_not_in?: String[] | String;
  securityCode_lt?: String;
  securityCode_lte?: String;
  securityCode_gt?: String;
  securityCode_gte?: String;
  securityCode_contains?: String;
  securityCode_not_contains?: String;
  securityCode_starts_with?: String;
  securityCode_not_starts_with?: String;
  securityCode_ends_with?: String;
  securityCode_not_ends_with?: String;
  firstName?: String;
  firstName_not?: String;
  firstName_in?: String[] | String;
  firstName_not_in?: String[] | String;
  firstName_lt?: String;
  firstName_lte?: String;
  firstName_gt?: String;
  firstName_gte?: String;
  firstName_contains?: String;
  firstName_not_contains?: String;
  firstName_starts_with?: String;
  firstName_not_starts_with?: String;
  firstName_ends_with?: String;
  firstName_not_ends_with?: String;
  lastName?: String;
  lastName_not?: String;
  lastName_in?: String[] | String;
  lastName_not_in?: String[] | String;
  lastName_lt?: String;
  lastName_lte?: String;
  lastName_gt?: String;
  lastName_gte?: String;
  lastName_contains?: String;
  lastName_not_contains?: String;
  lastName_starts_with?: String;
  lastName_not_starts_with?: String;
  lastName_ends_with?: String;
  lastName_not_ends_with?: String;
  postalCode?: String;
  postalCode_not?: String;
  postalCode_in?: String[] | String;
  postalCode_not_in?: String[] | String;
  postalCode_lt?: String;
  postalCode_lte?: String;
  postalCode_gt?: String;
  postalCode_gte?: String;
  postalCode_contains?: String;
  postalCode_not_contains?: String;
  postalCode_starts_with?: String;
  postalCode_not_starts_with?: String;
  postalCode_ends_with?: String;
  postalCode_not_ends_with?: String;
  country?: String;
  country_not?: String;
  country_in?: String[] | String;
  country_not_in?: String[] | String;
  country_lt?: String;
  country_lte?: String;
  country_gt?: String;
  country_gte?: String;
  country_contains?: String;
  country_not_contains?: String;
  country_starts_with?: String;
  country_not_starts_with?: String;
  country_ends_with?: String;
  country_not_ends_with?: String;
  paymentAccount?: PaymentAccountWhereInput;
  AND?: CreditCardInformationWhereInput[] | CreditCardInformationWhereInput;
  OR?: CreditCardInformationWhereInput[] | CreditCardInformationWhereInput;
  NOT?: CreditCardInformationWhereInput[] | CreditCardInformationWhereInput;
}

export interface ExperienceCreateManyWithoutHostInput {
  create?:
    | ExperienceCreateWithoutHostInput[]
    | ExperienceCreateWithoutHostInput;
  connect?: ExperienceWhereUniqueInput[] | ExperienceWhereUniqueInput;
}

export interface ReviewSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ReviewWhereInput;
  AND?: ReviewSubscriptionWhereInput[] | ReviewSubscriptionWhereInput;
  OR?: ReviewSubscriptionWhereInput[] | ReviewSubscriptionWhereInput;
  NOT?: ReviewSubscriptionWhereInput[] | ReviewSubscriptionWhereInput;
}

export interface ExperienceCreateWithoutHostInput {
  category?: ExperienceCategoryCreateOneWithoutExperienceInput;
  title: String;
  location: LocationCreateOneWithoutExperienceInput;
  pricePerPerson: Int;
  reviews?: ReviewCreateManyWithoutExperienceInput;
  preview: PictureCreateOneInput;
  popularity: Int;
}

export interface RestaurantSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: RestaurantWhereInput;
  AND?: RestaurantSubscriptionWhereInput[] | RestaurantSubscriptionWhereInput;
  OR?: RestaurantSubscriptionWhereInput[] | RestaurantSubscriptionWhereInput;
  NOT?: RestaurantSubscriptionWhereInput[] | RestaurantSubscriptionWhereInput;
}

export interface LocationCreateOneWithoutExperienceInput {
  create?: LocationCreateWithoutExperienceInput;
  connect?: LocationWhereUniqueInput;
}

export interface PaymentAccountWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  type?: PAYMENT_PROVIDER;
  type_not?: PAYMENT_PROVIDER;
  type_in?: PAYMENT_PROVIDER[] | PAYMENT_PROVIDER;
  type_not_in?: PAYMENT_PROVIDER[] | PAYMENT_PROVIDER;
  user?: UserWhereInput;
  payments_every?: PaymentWhereInput;
  payments_some?: PaymentWhereInput;
  payments_none?: PaymentWhereInput;
  paypal?: PaypalInformationWhereInput;
  creditcard?: CreditCardInformationWhereInput;
  AND?: PaymentAccountWhereInput[] | PaymentAccountWhereInput;
  OR?: PaymentAccountWhereInput[] | PaymentAccountWhereInput;
  NOT?: PaymentAccountWhereInput[] | PaymentAccountWhereInput;
}

export interface LocationCreateWithoutExperienceInput {
  lat: Float;
  lng: Float;
  neighbourHood?: NeighbourhoodCreateOneWithoutLocationsInput;
  user?: UserCreateOneWithoutLocationInput;
  place?: PlaceCreateOneWithoutLocationInput;
  address: String;
  directions: String;
  restaurant?: RestaurantCreateOneWithoutLocationInput;
}

export interface PaymentWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  serviceFee?: Float;
  serviceFee_not?: Float;
  serviceFee_in?: Float[] | Float;
  serviceFee_not_in?: Float[] | Float;
  serviceFee_lt?: Float;
  serviceFee_lte?: Float;
  serviceFee_gt?: Float;
  serviceFee_gte?: Float;
  placePrice?: Float;
  placePrice_not?: Float;
  placePrice_in?: Float[] | Float;
  placePrice_not_in?: Float[] | Float;
  placePrice_lt?: Float;
  placePrice_lte?: Float;
  placePrice_gt?: Float;
  placePrice_gte?: Float;
  totalPrice?: Float;
  totalPrice_not?: Float;
  totalPrice_in?: Float[] | Float;
  totalPrice_not_in?: Float[] | Float;
  totalPrice_lt?: Float;
  totalPrice_lte?: Float;
  totalPrice_gt?: Float;
  totalPrice_gte?: Float;
  booking?: BookingWhereInput;
  paymentMethod?: PaymentAccountWhereInput;
  AND?: PaymentWhereInput[] | PaymentWhereInput;
  OR?: PaymentWhereInput[] | PaymentWhereInput;
  NOT?: PaymentWhereInput[] | PaymentWhereInput;
}

export interface RestaurantCreateOneWithoutLocationInput {
  create?: RestaurantCreateWithoutLocationInput;
  connect?: RestaurantWhereUniqueInput;
}

export interface PlaceSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PlaceWhereInput;
  AND?: PlaceSubscriptionWhereInput[] | PlaceSubscriptionWhereInput;
  OR?: PlaceSubscriptionWhereInput[] | PlaceSubscriptionWhereInput;
  NOT?: PlaceSubscriptionWhereInput[] | PlaceSubscriptionWhereInput;
}

export interface RestaurantCreateWithoutLocationInput {
  title: String;
  avgPricePerPerson: Int;
  pictures?: PictureCreateManyInput;
  isCurated?: Boolean;
  slug: String;
  popularity: Int;
}

export interface PaypalInformationSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PaypalInformationWhereInput;
  AND?:
    | PaypalInformationSubscriptionWhereInput[]
    | PaypalInformationSubscriptionWhereInput;
  OR?:
    | PaypalInformationSubscriptionWhereInput[]
    | PaypalInformationSubscriptionWhereInput;
  NOT?:
    | PaypalInformationSubscriptionWhereInput[]
    | PaypalInformationSubscriptionWhereInput;
}

export interface PictureCreateManyInput {
  create?: PictureCreateInput[] | PictureCreateInput;
  connect?: PictureWhereUniqueInput[] | PictureWhereUniqueInput;
}

export interface PaymentAccountSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PaymentAccountWhereInput;
  AND?:
    | PaymentAccountSubscriptionWhereInput[]
    | PaymentAccountSubscriptionWhereInput;
  OR?:
    | PaymentAccountSubscriptionWhereInput[]
    | PaymentAccountSubscriptionWhereInput;
  NOT?:
    | PaymentAccountSubscriptionWhereInput[]
    | PaymentAccountSubscriptionWhereInput;
}

export interface ReviewCreateManyWithoutExperienceInput {
  create?:
    | ReviewCreateWithoutExperienceInput[]
    | ReviewCreateWithoutExperienceInput;
  connect?: ReviewWhereUniqueInput[] | ReviewWhereUniqueInput;
}

export interface ExperienceCategoryWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  mainColor?: String;
  mainColor_not?: String;
  mainColor_in?: String[] | String;
  mainColor_not_in?: String[] | String;
  mainColor_lt?: String;
  mainColor_lte?: String;
  mainColor_gt?: String;
  mainColor_gte?: String;
  mainColor_contains?: String;
  mainColor_not_contains?: String;
  mainColor_starts_with?: String;
  mainColor_not_starts_with?: String;
  mainColor_ends_with?: String;
  mainColor_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  experience?: ExperienceWhereInput;
  AND?: ExperienceCategoryWhereInput[] | ExperienceCategoryWhereInput;
  OR?: ExperienceCategoryWhereInput[] | ExperienceCategoryWhereInput;
  NOT?: ExperienceCategoryWhereInput[] | ExperienceCategoryWhereInput;
}

export interface ReviewCreateWithoutExperienceInput {
  text: String;
  stars: Int;
  accuracy: Int;
  location: Int;
  checkIn: Int;
  value: Int;
  cleanliness: Int;
  communication: Int;
  place: PlaceCreateOneWithoutReviewsInput;
}

export interface NotificationSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: NotificationWhereInput;
  AND?:
    | NotificationSubscriptionWhereInput[]
    | NotificationSubscriptionWhereInput;
  OR?:
    | NotificationSubscriptionWhereInput[]
    | NotificationSubscriptionWhereInput;
  NOT?:
    | NotificationSubscriptionWhereInput[]
    | NotificationSubscriptionWhereInput;
}

export interface PlaceCreateOneWithoutReviewsInput {
  create?: PlaceCreateWithoutReviewsInput;
  connect?: PlaceWhereUniqueInput;
}

export interface NeighbourhoodSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: NeighbourhoodWhereInput;
  AND?:
    | NeighbourhoodSubscriptionWhereInput[]
    | NeighbourhoodSubscriptionWhereInput;
  OR?:
    | NeighbourhoodSubscriptionWhereInput[]
    | NeighbourhoodSubscriptionWhereInput;
  NOT?:
    | NeighbourhoodSubscriptionWhereInput[]
    | NeighbourhoodSubscriptionWhereInput;
}

export interface PlaceCreateWithoutReviewsInput {
  name: String;
  size?: PLACE_SIZES;
  shortDescription: String;
  description: String;
  slug: String;
  maxGuests: Int;
  numBedrooms: Int;
  numBeds: Int;
  numBaths: Int;
  amenities: AmenitiesCreateOneWithoutPlaceInput;
  host: UserCreateOneWithoutOwnedPlacesInput;
  pricing: PricingCreateOneWithoutPlaceInput;
  location: LocationCreateOneWithoutPlaceInput;
  views: ViewsCreateOneWithoutPlaceInput;
  guestRequirements?: GuestRequirementsCreateOneWithoutPlaceInput;
  policies?: PoliciesCreateOneWithoutPlaceInput;
  houseRules?: HouseRulesCreateOneInput;
  bookings?: BookingCreateManyWithoutPlaceInput;
  pictures?: PictureCreateManyInput;
  popularity: Int;
}

export interface MessageSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: MessageWhereInput;
  AND?: MessageSubscriptionWhereInput[] | MessageSubscriptionWhereInput;
  OR?: MessageSubscriptionWhereInput[] | MessageSubscriptionWhereInput;
  NOT?: MessageSubscriptionWhereInput[] | MessageSubscriptionWhereInput;
}

export interface MessageCreateManyWithoutToInput {
  create?: MessageCreateWithoutToInput[] | MessageCreateWithoutToInput;
  connect?: MessageWhereUniqueInput[] | MessageWhereUniqueInput;
}

export interface HouseRulesSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: HouseRulesWhereInput;
  AND?: HouseRulesSubscriptionWhereInput[] | HouseRulesSubscriptionWhereInput;
  OR?: HouseRulesSubscriptionWhereInput[] | HouseRulesSubscriptionWhereInput;
  NOT?: HouseRulesSubscriptionWhereInput[] | HouseRulesSubscriptionWhereInput;
}

export interface MessageCreateWithoutToInput {
  from: UserCreateOneWithoutSentMessagesInput;
  deliveredAt: DateTimeInput;
  readAt: DateTimeInput;
}

export interface ExperienceCategorySubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ExperienceCategoryWhereInput;
  AND?:
    | ExperienceCategorySubscriptionWhereInput[]
    | ExperienceCategorySubscriptionWhereInput;
  OR?:
    | ExperienceCategorySubscriptionWhereInput[]
    | ExperienceCategorySubscriptionWhereInput;
  NOT?:
    | ExperienceCategorySubscriptionWhereInput[]
    | ExperienceCategorySubscriptionWhereInput;
}

export interface UserCreateOneWithoutSentMessagesInput {
  create?: UserCreateWithoutSentMessagesInput;
  connect?: UserWhereUniqueInput;
}

export interface ExperienceSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ExperienceWhereInput;
  AND?: ExperienceSubscriptionWhereInput[] | ExperienceSubscriptionWhereInput;
  OR?: ExperienceSubscriptionWhereInput[] | ExperienceSubscriptionWhereInput;
  NOT?: ExperienceSubscriptionWhereInput[] | ExperienceSubscriptionWhereInput;
}

export interface UserCreateWithoutSentMessagesInput {
  firstName: String;
  lastName: String;
  email: String;
  password: String;
  phone: String;
  responseRate?: Float;
  responseTime?: Int;
  isSuperHost?: Boolean;
  ownedPlaces?: PlaceCreateManyWithoutHostInput;
  location?: LocationCreateOneWithoutUserInput;
  bookings?: BookingCreateManyWithoutBookeeInput;
  paymentAccount?: PaymentAccountCreateManyWithoutUserInput;
  receivedMessages?: MessageCreateManyWithoutToInput;
  notifications?: NotificationCreateManyWithoutUserInput;
  profilePicture?: PictureCreateOneInput;
  hostingExperiences?: ExperienceCreateManyWithoutHostInput;
}

export interface CitySubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CityWhereInput;
  AND?: CitySubscriptionWhereInput[] | CitySubscriptionWhereInput;
  OR?: CitySubscriptionWhereInput[] | CitySubscriptionWhereInput;
  NOT?: CitySubscriptionWhereInput[] | CitySubscriptionWhereInput;
}

export interface PaymentCreateOneWithoutBookingInput {
  create?: PaymentCreateWithoutBookingInput;
  connect?: PaymentWhereUniqueInput;
}

export type BookingWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface PaymentCreateWithoutBookingInput {
  serviceFee: Float;
  placePrice: Float;
  totalPrice: Float;
  paymentMethod: PaymentAccountCreateOneWithoutPaymentsInput;
}

export interface PlaceUpsertWithoutViewsInput {
  update: PlaceUpdateWithoutViewsDataInput;
  create: PlaceCreateWithoutViewsInput;
}

export interface PaymentAccountCreateOneWithoutPaymentsInput {
  create?: PaymentAccountCreateWithoutPaymentsInput;
  connect?: PaymentAccountWhereUniqueInput;
}

export type CityWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface PaymentAccountCreateWithoutPaymentsInput {
  type?: PAYMENT_PROVIDER;
  user: UserCreateOneWithoutPaymentAccountInput;
  paypal?: PaypalInformationCreateOneWithoutPaymentAccountInput;
  creditcard?: CreditCardInformationCreateOneWithoutPaymentAccountInput;
}

export interface PlaceUpdateOneRequiredWithoutViewsInput {
  create?: PlaceCreateWithoutViewsInput;
  update?: PlaceUpdateWithoutViewsDataInput;
  upsert?: PlaceUpsertWithoutViewsInput;
  connect?: PlaceWhereUniqueInput;
}

export interface UserCreateOneWithoutPaymentAccountInput {
  create?: UserCreateWithoutPaymentAccountInput;
  connect?: UserWhereUniqueInput;
}

export interface PlaceCreateWithoutViewsInput {
  name: String;
  size?: PLACE_SIZES;
  shortDescription: String;
  description: String;
  slug: String;
  maxGuests: Int;
  numBedrooms: Int;
  numBeds: Int;
  numBaths: Int;
  reviews?: ReviewCreateManyWithoutPlaceInput;
  amenities: AmenitiesCreateOneWithoutPlaceInput;
  host: UserCreateOneWithoutOwnedPlacesInput;
  pricing: PricingCreateOneWithoutPlaceInput;
  location: LocationCreateOneWithoutPlaceInput;
  guestRequirements?: GuestRequirementsCreateOneWithoutPlaceInput;
  policies?: PoliciesCreateOneWithoutPlaceInput;
  houseRules?: HouseRulesCreateOneInput;
  bookings?: BookingCreateManyWithoutPlaceInput;
  pictures?: PictureCreateManyInput;
  popularity: Int;
}

export interface UserCreateWithoutPaymentAccountInput {
  firstName: String;
  lastName: String;
  email: String;
  password: String;
  phone: String;
  responseRate?: Float;
  responseTime?: Int;
  isSuperHost?: Boolean;
  ownedPlaces?: PlaceCreateManyWithoutHostInput;
  location?: LocationCreateOneWithoutUserInput;
  bookings?: BookingCreateManyWithoutBookeeInput;
  sentMessages?: MessageCreateManyWithoutFromInput;
  receivedMessages?: MessageCreateManyWithoutToInput;
  notifications?: NotificationCreateManyWithoutUserInput;
  profilePicture?: PictureCreateOneInput;
  hostingExperiences?: ExperienceCreateManyWithoutHostInput;
}

export interface PlaceCreateOneWithoutViewsInput {
  create?: PlaceCreateWithoutViewsInput;
  connect?: PlaceWhereUniqueInput;
}

export interface ExperienceCreateOneWithoutLocationInput {
  create?: ExperienceCreateWithoutLocationInput;
  connect?: ExperienceWhereUniqueInput;
}

export interface UserUpdateInput {
  firstName?: String;
  lastName?: String;
  email?: String;
  password?: String;
  phone?: String;
  responseRate?: Float;
  responseTime?: Int;
  isSuperHost?: Boolean;
  ownedPlaces?: PlaceUpdateManyWithoutHostInput;
  location?: LocationUpdateOneWithoutUserInput;
  bookings?: BookingUpdateManyWithoutBookeeInput;
  paymentAccount?: PaymentAccountUpdateManyWithoutUserInput;
  sentMessages?: MessageUpdateManyWithoutFromInput;
  receivedMessages?: MessageUpdateManyWithoutToInput;
  notifications?: NotificationUpdateManyWithoutUserInput;
  profilePicture?: PictureUpdateOneInput;
  hostingExperiences?: ExperienceUpdateManyWithoutHostInput;
}

export interface ExperienceCreateWithoutLocationInput {
  category?: ExperienceCategoryCreateOneWithoutExperienceInput;
  title: String;
  host: UserCreateOneWithoutHostingExperiencesInput;
  pricePerPerson: Int;
  reviews?: ReviewCreateManyWithoutExperienceInput;
  preview: PictureCreateOneInput;
  popularity: Int;
}

export type ExperienceWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface AmenitiesUpdateInput {
  place?: PlaceUpdateOneRequiredWithoutAmenitiesInput;
  elevator?: Boolean;
  petsAllowed?: Boolean;
  internet?: Boolean;
  kitchen?: Boolean;
  wirelessInternet?: Boolean;
  familyKidFriendly?: Boolean;
  freeParkingOnPremises?: Boolean;
  hotTub?: Boolean;
  pool?: Boolean;
  smokingAllowed?: Boolean;
  wheelchairAccessible?: Boolean;
  breakfast?: Boolean;
  cableTv?: Boolean;
  suitableForEvents?: Boolean;
  dryer?: Boolean;
  washer?: Boolean;
  indoorFireplace?: Boolean;
  tv?: Boolean;
  heating?: Boolean;
  hangers?: Boolean;
  iron?: Boolean;
  hairDryer?: Boolean;
  doorman?: Boolean;
  paidParkingOffPremises?: Boolean;
  freeParkingOnStreet?: Boolean;
  gym?: Boolean;
  airConditioning?: Boolean;
  shampoo?: Boolean;
  essentials?: Boolean;
  laptopFriendlyWorkspace?: Boolean;
  privateEntrance?: Boolean;
  buzzerWirelessIntercom?: Boolean;
  babyBath?: Boolean;
  babyMonitor?: Boolean;
  babysitterRecommendations?: Boolean;
  bathtub?: Boolean;
  changingTable?: Boolean;
  childrensBooksAndToys?: Boolean;
  childrensDinnerware?: Boolean;
  crib?: Boolean;
}

export interface ReviewCreateInput {
  text: String;
  stars: Int;
  accuracy: Int;
  location: Int;
  checkIn: Int;
  value: Int;
  cleanliness: Int;
  communication: Int;
  place: PlaceCreateOneWithoutReviewsInput;
  experience?: ExperienceCreateOneWithoutReviewsInput;
}

export interface PlaceUpdateOneRequiredWithoutAmenitiesInput {
  create?: PlaceCreateWithoutAmenitiesInput;
  update?: PlaceUpdateWithoutAmenitiesDataInput;
  upsert?: PlaceUpsertWithoutAmenitiesInput;
  connect?: PlaceWhereUniqueInput;
}

export type ExperienceCategoryWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface PlaceUpdateWithoutAmenitiesDataInput {
  name?: String;
  size?: PLACE_SIZES;
  shortDescription?: String;
  description?: String;
  slug?: String;
  maxGuests?: Int;
  numBedrooms?: Int;
  numBeds?: Int;
  numBaths?: Int;
  reviews?: ReviewUpdateManyWithoutPlaceInput;
  host?: UserUpdateOneRequiredWithoutOwnedPlacesInput;
  pricing?: PricingUpdateOneRequiredWithoutPlaceInput;
  location?: LocationUpdateOneRequiredWithoutPlaceInput;
  views?: ViewsUpdateOneRequiredWithoutPlaceInput;
  guestRequirements?: GuestRequirementsUpdateOneWithoutPlaceInput;
  policies?: PoliciesUpdateOneWithoutPlaceInput;
  houseRules?: HouseRulesUpdateOneInput;
  bookings?: BookingUpdateManyWithoutPlaceInput;
  pictures?: PictureUpdateManyInput;
  popularity?: Int;
}

export interface LocationUpdateWithoutRestaurantDataInput {
  lat?: Float;
  lng?: Float;
  neighbourHood?: NeighbourhoodUpdateOneWithoutLocationsInput;
  user?: UserUpdateOneWithoutLocationInput;
  place?: PlaceUpdateOneWithoutLocationInput;
  address?: String;
  directions?: String;
  experience?: ExperienceUpdateOneWithoutLocationInput;
}

export interface ReviewUpdateManyWithoutPlaceInput {
  create?: ReviewCreateWithoutPlaceInput[] | ReviewCreateWithoutPlaceInput;
  delete?: ReviewWhereUniqueInput[] | ReviewWhereUniqueInput;
  connect?: ReviewWhereUniqueInput[] | ReviewWhereUniqueInput;
  disconnect?: ReviewWhereUniqueInput[] | ReviewWhereUniqueInput;
  update?:
    | ReviewUpdateWithWhereUniqueWithoutPlaceInput[]
    | ReviewUpdateWithWhereUniqueWithoutPlaceInput;
  upsert?:
    | ReviewUpsertWithWhereUniqueWithoutPlaceInput[]
    | ReviewUpsertWithWhereUniqueWithoutPlaceInput;
}

export interface RestaurantUpdateInput {
  title?: String;
  avgPricePerPerson?: Int;
  pictures?: PictureUpdateManyInput;
  location?: LocationUpdateOneRequiredWithoutRestaurantInput;
  isCurated?: Boolean;
  slug?: String;
  popularity?: Int;
}

export interface ReviewUpdateWithWhereUniqueWithoutPlaceInput {
  where: ReviewWhereUniqueInput;
  data: ReviewUpdateWithoutPlaceDataInput;
}

export interface LocationCreateWithoutRestaurantInput {
  lat: Float;
  lng: Float;
  neighbourHood?: NeighbourhoodCreateOneWithoutLocationsInput;
  user?: UserCreateOneWithoutLocationInput;
  place?: PlaceCreateOneWithoutLocationInput;
  address: String;
  directions: String;
  experience?: ExperienceCreateOneWithoutLocationInput;
}

export interface ReviewUpdateWithoutPlaceDataInput {
  text?: String;
  stars?: Int;
  accuracy?: Int;
  location?: Int;
  checkIn?: Int;
  value?: Int;
  cleanliness?: Int;
  communication?: Int;
  experience?: ExperienceUpdateOneWithoutReviewsInput;
}

export interface RestaurantCreateInput {
  title: String;
  avgPricePerPerson: Int;
  pictures?: PictureCreateManyInput;
  location: LocationCreateOneWithoutRestaurantInput;
  isCurated?: Boolean;
  slug: String;
  popularity: Int;
}

export interface ExperienceUpdateOneWithoutReviewsInput {
  create?: ExperienceCreateWithoutReviewsInput;
  update?: ExperienceUpdateWithoutReviewsDataInput;
  upsert?: ExperienceUpsertWithoutReviewsInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: ExperienceWhereUniqueInput;
}

export type HouseRulesWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ExperienceUpdateWithoutReviewsDataInput {
  category?: ExperienceCategoryUpdateOneWithoutExperienceInput;
  title?: String;
  host?: UserUpdateOneRequiredWithoutHostingExperiencesInput;
  location?: LocationUpdateOneRequiredWithoutExperienceInput;
  pricePerPerson?: Int;
  preview?: PictureUpdateOneRequiredInput;
  popularity?: Int;
}

export interface PlaceUpdateWithoutPricingDataInput {
  name?: String;
  size?: PLACE_SIZES;
  shortDescription?: String;
  description?: String;
  slug?: String;
  maxGuests?: Int;
  numBedrooms?: Int;
  numBeds?: Int;
  numBaths?: Int;
  reviews?: ReviewUpdateManyWithoutPlaceInput;
  amenities?: AmenitiesUpdateOneRequiredWithoutPlaceInput;
  host?: UserUpdateOneRequiredWithoutOwnedPlacesInput;
  location?: LocationUpdateOneRequiredWithoutPlaceInput;
  views?: ViewsUpdateOneRequiredWithoutPlaceInput;
  guestRequirements?: GuestRequirementsUpdateOneWithoutPlaceInput;
  policies?: PoliciesUpdateOneWithoutPlaceInput;
  houseRules?: HouseRulesUpdateOneInput;
  bookings?: BookingUpdateManyWithoutPlaceInput;
  pictures?: PictureUpdateManyInput;
  popularity?: Int;
}

export interface ExperienceCategoryUpdateOneWithoutExperienceInput {
  create?: ExperienceCategoryCreateWithoutExperienceInput;
  update?: ExperienceCategoryUpdateWithoutExperienceDataInput;
  upsert?: ExperienceCategoryUpsertWithoutExperienceInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: ExperienceCategoryWhereUniqueInput;
}

export interface PricingUpdateInput {
  place?: PlaceUpdateOneRequiredWithoutPricingInput;
  monthlyDiscount?: Int;
  weeklyDiscount?: Int;
  perNight?: Int;
  smartPricing?: Boolean;
  basePrice?: Int;
  averageWeekly?: Int;
  averageMonthly?: Int;
  cleaningFee?: Int;
  securityDeposit?: Int;
  extraGuests?: Int;
  weekendPricing?: Int;
  currency?: CURRENCY;
}

export interface ExperienceCategoryUpdateWithoutExperienceDataInput {
  mainColor?: String;
  name?: String;
}

export interface PlaceCreateWithoutPricingInput {
  name: String;
  size?: PLACE_SIZES;
  shortDescription: String;
  description: String;
  slug: String;
  maxGuests: Int;
  numBedrooms: Int;
  numBeds: Int;
  numBaths: Int;
  reviews?: ReviewCreateManyWithoutPlaceInput;
  amenities: AmenitiesCreateOneWithoutPlaceInput;
  host: UserCreateOneWithoutOwnedPlacesInput;
  location: LocationCreateOneWithoutPlaceInput;
  views: ViewsCreateOneWithoutPlaceInput;
  guestRequirements?: GuestRequirementsCreateOneWithoutPlaceInput;
  policies?: PoliciesCreateOneWithoutPlaceInput;
  houseRules?: HouseRulesCreateOneInput;
  bookings?: BookingCreateManyWithoutPlaceInput;
  pictures?: PictureCreateManyInput;
  popularity: Int;
}

export interface ExperienceCategoryUpsertWithoutExperienceInput {
  update: ExperienceCategoryUpdateWithoutExperienceDataInput;
  create: ExperienceCategoryCreateWithoutExperienceInput;
}

export interface PricingCreateInput {
  place: PlaceCreateOneWithoutPricingInput;
  monthlyDiscount?: Int;
  weeklyDiscount?: Int;
  perNight: Int;
  smartPricing?: Boolean;
  basePrice: Int;
  averageWeekly: Int;
  averageMonthly: Int;
  cleaningFee?: Int;
  securityDeposit?: Int;
  extraGuests?: Int;
  weekendPricing?: Int;
  currency?: CURRENCY;
}

export interface UserUpdateOneRequiredWithoutHostingExperiencesInput {
  create?: UserCreateWithoutHostingExperiencesInput;
  update?: UserUpdateWithoutHostingExperiencesDataInput;
  upsert?: UserUpsertWithoutHostingExperiencesInput;
  connect?: UserWhereUniqueInput;
}

export interface PlaceUpsertWithoutPoliciesInput {
  update: PlaceUpdateWithoutPoliciesDataInput;
  create: PlaceCreateWithoutPoliciesInput;
}

export interface UserUpdateWithoutHostingExperiencesDataInput {
  firstName?: String;
  lastName?: String;
  email?: String;
  password?: String;
  phone?: String;
  responseRate?: Float;
  responseTime?: Int;
  isSuperHost?: Boolean;
  ownedPlaces?: PlaceUpdateManyWithoutHostInput;
  location?: LocationUpdateOneWithoutUserInput;
  bookings?: BookingUpdateManyWithoutBookeeInput;
  paymentAccount?: PaymentAccountUpdateManyWithoutUserInput;
  sentMessages?: MessageUpdateManyWithoutFromInput;
  receivedMessages?: MessageUpdateManyWithoutToInput;
  notifications?: NotificationUpdateManyWithoutUserInput;
  profilePicture?: PictureUpdateOneInput;
}

export interface PlaceUpdateOneRequiredWithoutPoliciesInput {
  create?: PlaceCreateWithoutPoliciesInput;
  update?: PlaceUpdateWithoutPoliciesDataInput;
  upsert?: PlaceUpsertWithoutPoliciesInput;
  connect?: PlaceWhereUniqueInput;
}

export interface PlaceUpdateManyWithoutHostInput {
  create?: PlaceCreateWithoutHostInput[] | PlaceCreateWithoutHostInput;
  delete?: PlaceWhereUniqueInput[] | PlaceWhereUniqueInput;
  connect?: PlaceWhereUniqueInput[] | PlaceWhereUniqueInput;
  disconnect?: PlaceWhereUniqueInput[] | PlaceWhereUniqueInput;
  update?:
    | PlaceUpdateWithWhereUniqueWithoutHostInput[]
    | PlaceUpdateWithWhereUniqueWithoutHostInput;
  upsert?:
    | PlaceUpsertWithWhereUniqueWithoutHostInput[]
    | PlaceUpsertWithWhereUniqueWithoutHostInput;
}

export interface PoliciesUpdateInput {
  checkInStartTime?: Float;
  checkInEndTime?: Float;
  checkoutTime?: Float;
  place?: PlaceUpdateOneRequiredWithoutPoliciesInput;
}

export interface PlaceUpdateWithWhereUniqueWithoutHostInput {
  where: PlaceWhereUniqueInput;
  data: PlaceUpdateWithoutHostDataInput;
}

export interface PlaceCreateOneWithoutPoliciesInput {
  create?: PlaceCreateWithoutPoliciesInput;
  connect?: PlaceWhereUniqueInput;
}

export interface PlaceUpdateWithoutHostDataInput {
  name?: String;
  size?: PLACE_SIZES;
  shortDescription?: String;
  description?: String;
  slug?: String;
  maxGuests?: Int;
  numBedrooms?: Int;
  numBeds?: Int;
  numBaths?: Int;
  reviews?: ReviewUpdateManyWithoutPlaceInput;
  amenities?: AmenitiesUpdateOneRequiredWithoutPlaceInput;
  pricing?: PricingUpdateOneRequiredWithoutPlaceInput;
  location?: LocationUpdateOneRequiredWithoutPlaceInput;
  views?: ViewsUpdateOneRequiredWithoutPlaceInput;
  guestRequirements?: GuestRequirementsUpdateOneWithoutPlaceInput;
  policies?: PoliciesUpdateOneWithoutPlaceInput;
  houseRules?: HouseRulesUpdateOneInput;
  bookings?: BookingUpdateManyWithoutPlaceInput;
  pictures?: PictureUpdateManyInput;
  popularity?: Int;
}

export interface PoliciesCreateInput {
  checkInStartTime: Float;
  checkInEndTime: Float;
  checkoutTime: Float;
  place: PlaceCreateOneWithoutPoliciesInput;
}

export interface AmenitiesUpdateOneRequiredWithoutPlaceInput {
  create?: AmenitiesCreateWithoutPlaceInput;
  update?: AmenitiesUpdateWithoutPlaceDataInput;
  upsert?: AmenitiesUpsertWithoutPlaceInput;
  connect?: AmenitiesWhereUniqueInput;
}

export interface PlaceCreateInput {
  name: String;
  size?: PLACE_SIZES;
  shortDescription: String;
  description: String;
  slug: String;
  maxGuests: Int;
  numBedrooms: Int;
  numBeds: Int;
  numBaths: Int;
  reviews?: ReviewCreateManyWithoutPlaceInput;
  amenities: AmenitiesCreateOneWithoutPlaceInput;
  host: UserCreateOneWithoutOwnedPlacesInput;
  pricing: PricingCreateOneWithoutPlaceInput;
  location: LocationCreateOneWithoutPlaceInput;
  views: ViewsCreateOneWithoutPlaceInput;
  guestRequirements?: GuestRequirementsCreateOneWithoutPlaceInput;
  policies?: PoliciesCreateOneWithoutPlaceInput;
  houseRules?: HouseRulesCreateOneInput;
  bookings?: BookingCreateManyWithoutPlaceInput;
  pictures?: PictureCreateManyInput;
  popularity: Int;
}

export interface AmenitiesUpdateWithoutPlaceDataInput {
  elevator?: Boolean;
  petsAllowed?: Boolean;
  internet?: Boolean;
  kitchen?: Boolean;
  wirelessInternet?: Boolean;
  familyKidFriendly?: Boolean;
  freeParkingOnPremises?: Boolean;
  hotTub?: Boolean;
  pool?: Boolean;
  smokingAllowed?: Boolean;
  wheelchairAccessible?: Boolean;
  breakfast?: Boolean;
  cableTv?: Boolean;
  suitableForEvents?: Boolean;
  dryer?: Boolean;
  washer?: Boolean;
  indoorFireplace?: Boolean;
  tv?: Boolean;
  heating?: Boolean;
  hangers?: Boolean;
  iron?: Boolean;
  hairDryer?: Boolean;
  doorman?: Boolean;
  paidParkingOffPremises?: Boolean;
  freeParkingOnStreet?: Boolean;
  gym?: Boolean;
  airConditioning?: Boolean;
  shampoo?: Boolean;
  essentials?: Boolean;
  laptopFriendlyWorkspace?: Boolean;
  privateEntrance?: Boolean;
  buzzerWirelessIntercom?: Boolean;
  babyBath?: Boolean;
  babyMonitor?: Boolean;
  babysitterRecommendations?: Boolean;
  bathtub?: Boolean;
  changingTable?: Boolean;
  childrensBooksAndToys?: Boolean;
  childrensDinnerware?: Boolean;
  crib?: Boolean;
}

export interface PictureUpdateInput {
  url?: String;
}

export interface AmenitiesUpsertWithoutPlaceInput {
  update: AmenitiesUpdateWithoutPlaceDataInput;
  create: AmenitiesCreateWithoutPlaceInput;
}

export interface PaymentAccountUpdateWithoutPaypalDataInput {
  type?: PAYMENT_PROVIDER;
  user?: UserUpdateOneRequiredWithoutPaymentAccountInput;
  payments?: PaymentUpdateManyWithoutPaymentMethodInput;
  creditcard?: CreditCardInformationUpdateOneWithoutPaymentAccountInput;
}

export interface PricingUpdateOneRequiredWithoutPlaceInput {
  create?: PricingCreateWithoutPlaceInput;
  update?: PricingUpdateWithoutPlaceDataInput;
  upsert?: PricingUpsertWithoutPlaceInput;
  connect?: PricingWhereUniqueInput;
}

export interface PaymentAccountUpdateOneRequiredWithoutPaypalInput {
  create?: PaymentAccountCreateWithoutPaypalInput;
  update?: PaymentAccountUpdateWithoutPaypalDataInput;
  upsert?: PaymentAccountUpsertWithoutPaypalInput;
  connect?: PaymentAccountWhereUniqueInput;
}

export interface PricingUpdateWithoutPlaceDataInput {
  monthlyDiscount?: Int;
  weeklyDiscount?: Int;
  perNight?: Int;
  smartPricing?: Boolean;
  basePrice?: Int;
  averageWeekly?: Int;
  averageMonthly?: Int;
  cleaningFee?: Int;
  securityDeposit?: Int;
  extraGuests?: Int;
  weekendPricing?: Int;
  currency?: CURRENCY;
}

export interface PaymentAccountCreateWithoutPaypalInput {
  type?: PAYMENT_PROVIDER;
  user: UserCreateOneWithoutPaymentAccountInput;
  payments?: PaymentCreateManyWithoutPaymentMethodInput;
  creditcard?: CreditCardInformationCreateOneWithoutPaymentAccountInput;
}

export interface PricingUpsertWithoutPlaceInput {
  update: PricingUpdateWithoutPlaceDataInput;
  create: PricingCreateWithoutPlaceInput;
}

export interface PlaceWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  size?: PLACE_SIZES;
  size_not?: PLACE_SIZES;
  size_in?: PLACE_SIZES[] | PLACE_SIZES;
  size_not_in?: PLACE_SIZES[] | PLACE_SIZES;
  shortDescription?: String;
  shortDescription_not?: String;
  shortDescription_in?: String[] | String;
  shortDescription_not_in?: String[] | String;
  shortDescription_lt?: String;
  shortDescription_lte?: String;
  shortDescription_gt?: String;
  shortDescription_gte?: String;
  shortDescription_contains?: String;
  shortDescription_not_contains?: String;
  shortDescription_starts_with?: String;
  shortDescription_not_starts_with?: String;
  shortDescription_ends_with?: String;
  shortDescription_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  slug?: String;
  slug_not?: String;
  slug_in?: String[] | String;
  slug_not_in?: String[] | String;
  slug_lt?: String;
  slug_lte?: String;
  slug_gt?: String;
  slug_gte?: String;
  slug_contains?: String;
  slug_not_contains?: String;
  slug_starts_with?: String;
  slug_not_starts_with?: String;
  slug_ends_with?: String;
  slug_not_ends_with?: String;
  maxGuests?: Int;
  maxGuests_not?: Int;
  maxGuests_in?: Int[] | Int;
  maxGuests_not_in?: Int[] | Int;
  maxGuests_lt?: Int;
  maxGuests_lte?: Int;
  maxGuests_gt?: Int;
  maxGuests_gte?: Int;
  numBedrooms?: Int;
  numBedrooms_not?: Int;
  numBedrooms_in?: Int[] | Int;
  numBedrooms_not_in?: Int[] | Int;
  numBedrooms_lt?: Int;
  numBedrooms_lte?: Int;
  numBedrooms_gt?: Int;
  numBedrooms_gte?: Int;
  numBeds?: Int;
  numBeds_not?: Int;
  numBeds_in?: Int[] | Int;
  numBeds_not_in?: Int[] | Int;
  numBeds_lt?: Int;
  numBeds_lte?: Int;
  numBeds_gt?: Int;
  numBeds_gte?: Int;
  numBaths?: Int;
  numBaths_not?: Int;
  numBaths_in?: Int[] | Int;
  numBaths_not_in?: Int[] | Int;
  numBaths_lt?: Int;
  numBaths_lte?: Int;
  numBaths_gt?: Int;
  numBaths_gte?: Int;
  reviews_every?: ReviewWhereInput;
  reviews_some?: ReviewWhereInput;
  reviews_none?: ReviewWhereInput;
  amenities?: AmenitiesWhereInput;
  host?: UserWhereInput;
  pricing?: PricingWhereInput;
  location?: LocationWhereInput;
  views?: ViewsWhereInput;
  guestRequirements?: GuestRequirementsWhereInput;
  policies?: PoliciesWhereInput;
  houseRules?: HouseRulesWhereInput;
  bookings_every?: BookingWhereInput;
  bookings_some?: BookingWhereInput;
  bookings_none?: BookingWhereInput;
  pictures_every?: PictureWhereInput;
  pictures_some?: PictureWhereInput;
  pictures_none?: PictureWhereInput;
  popularity?: Int;
  popularity_not?: Int;
  popularity_in?: Int[] | Int;
  popularity_not_in?: Int[] | Int;
  popularity_lt?: Int;
  popularity_lte?: Int;
  popularity_gt?: Int;
  popularity_gte?: Int;
  AND?: PlaceWhereInput[] | PlaceWhereInput;
  OR?: PlaceWhereInput[] | PlaceWhereInput;
  NOT?: PlaceWhereInput[] | PlaceWhereInput;
}

export interface LocationUpdateOneRequiredWithoutPlaceInput {
  create?: LocationCreateWithoutPlaceInput;
  update?: LocationUpdateWithoutPlaceDataInput;
  upsert?: LocationUpsertWithoutPlaceInput;
  connect?: LocationWhereUniqueInput;
}

export interface PaypalInformationCreateInput {
  email: String;
  paymentAccount: PaymentAccountCreateOneWithoutPaypalInput;
}

export interface LocationUpdateWithoutPlaceDataInput {
  lat?: Float;
  lng?: Float;
  neighbourHood?: NeighbourhoodUpdateOneWithoutLocationsInput;
  user?: UserUpdateOneWithoutLocationInput;
  address?: String;
  directions?: String;
  experience?: ExperienceUpdateOneWithoutLocationInput;
  restaurant?: RestaurantUpdateOneWithoutLocationInput;
}

export type PictureWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface NeighbourhoodUpdateOneWithoutLocationsInput {
  create?: NeighbourhoodCreateWithoutLocationsInput;
  update?: NeighbourhoodUpdateWithoutLocationsDataInput;
  upsert?: NeighbourhoodUpsertWithoutLocationsInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: NeighbourhoodWhereUniqueInput;
}

export interface PaymentUpdateInput {
  serviceFee?: Float;
  placePrice?: Float;
  totalPrice?: Float;
  booking?: BookingUpdateOneRequiredWithoutPaymentInput;
  paymentMethod?: PaymentAccountUpdateOneRequiredWithoutPaymentsInput;
}

export interface NeighbourhoodUpdateWithoutLocationsDataInput {
  name?: String;
  slug?: String;
  homePreview?: PictureUpdateOneInput;
  city?: CityUpdateOneRequiredWithoutNeighbourhoodsInput;
  featured?: Boolean;
  popularity?: Int;
}

export type PlaceWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface PictureUpdateOneInput {
  create?: PictureCreateInput;
  update?: PictureUpdateDataInput;
  upsert?: PictureUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: PictureWhereUniqueInput;
}

export interface UserUpdateWithoutNotificationsDataInput {
  firstName?: String;
  lastName?: String;
  email?: String;
  password?: String;
  phone?: String;
  responseRate?: Float;
  responseTime?: Int;
  isSuperHost?: Boolean;
  ownedPlaces?: PlaceUpdateManyWithoutHostInput;
  location?: LocationUpdateOneWithoutUserInput;
  bookings?: BookingUpdateManyWithoutBookeeInput;
  paymentAccount?: PaymentAccountUpdateManyWithoutUserInput;
  sentMessages?: MessageUpdateManyWithoutFromInput;
  receivedMessages?: MessageUpdateManyWithoutToInput;
  profilePicture?: PictureUpdateOneInput;
  hostingExperiences?: ExperienceUpdateManyWithoutHostInput;
}

export interface ExperienceCreateWithoutCategoryInput {
  title: String;
  host: UserCreateOneWithoutHostingExperiencesInput;
  location: LocationCreateOneWithoutExperienceInput;
  pricePerPerson: Int;
  reviews?: ReviewCreateManyWithoutExperienceInput;
  preview: PictureCreateOneInput;
  popularity: Int;
}

export type PoliciesWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface PictureUpsertNestedInput {
  update: PictureUpdateDataInput;
  create: PictureCreateInput;
}

export interface UserCreateWithoutNotificationsInput {
  firstName: String;
  lastName: String;
  email: String;
  password: String;
  phone: String;
  responseRate?: Float;
  responseTime?: Int;
  isSuperHost?: Boolean;
  ownedPlaces?: PlaceCreateManyWithoutHostInput;
  location?: LocationCreateOneWithoutUserInput;
  bookings?: BookingCreateManyWithoutBookeeInput;
  paymentAccount?: PaymentAccountCreateManyWithoutUserInput;
  sentMessages?: MessageCreateManyWithoutFromInput;
  receivedMessages?: MessageCreateManyWithoutToInput;
  profilePicture?: PictureCreateOneInput;
  hostingExperiences?: ExperienceCreateManyWithoutHostInput;
}

export interface CityUpdateOneRequiredWithoutNeighbourhoodsInput {
  create?: CityCreateWithoutNeighbourhoodsInput;
  update?: CityUpdateWithoutNeighbourhoodsDataInput;
  upsert?: CityUpsertWithoutNeighbourhoodsInput;
  connect?: CityWhereUniqueInput;
}

export interface NotificationCreateInput {
  type?: NOTIFICATION_TYPE;
  user: UserCreateOneWithoutNotificationsInput;
  link: String;
  readDate: DateTimeInput;
}

export interface CityUpdateWithoutNeighbourhoodsDataInput {
  name?: String;
}

export interface ReviewWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  text?: String;
  text_not?: String;
  text_in?: String[] | String;
  text_not_in?: String[] | String;
  text_lt?: String;
  text_lte?: String;
  text_gt?: String;
  text_gte?: String;
  text_contains?: String;
  text_not_contains?: String;
  text_starts_with?: String;
  text_not_starts_with?: String;
  text_ends_with?: String;
  text_not_ends_with?: String;
  stars?: Int;
  stars_not?: Int;
  stars_in?: Int[] | Int;
  stars_not_in?: Int[] | Int;
  stars_lt?: Int;
  stars_lte?: Int;
  stars_gt?: Int;
  stars_gte?: Int;
  accuracy?: Int;
  accuracy_not?: Int;
  accuracy_in?: Int[] | Int;
  accuracy_not_in?: Int[] | Int;
  accuracy_lt?: Int;
  accuracy_lte?: Int;
  accuracy_gt?: Int;
  accuracy_gte?: Int;
  location?: Int;
  location_not?: Int;
  location_in?: Int[] | Int;
  location_not_in?: Int[] | Int;
  location_lt?: Int;
  location_lte?: Int;
  location_gt?: Int;
  location_gte?: Int;
  checkIn?: Int;
  checkIn_not?: Int;
  checkIn_in?: Int[] | Int;
  checkIn_not_in?: Int[] | Int;
  checkIn_lt?: Int;
  checkIn_lte?: Int;
  checkIn_gt?: Int;
  checkIn_gte?: Int;
  value?: Int;
  value_not?: Int;
  value_in?: Int[] | Int;
  value_not_in?: Int[] | Int;
  value_lt?: Int;
  value_lte?: Int;
  value_gt?: Int;
  value_gte?: Int;
  cleanliness?: Int;
  cleanliness_not?: Int;
  cleanliness_in?: Int[] | Int;
  cleanliness_not_in?: Int[] | Int;
  cleanliness_lt?: Int;
  cleanliness_lte?: Int;
  cleanliness_gt?: Int;
  cleanliness_gte?: Int;
  communication?: Int;
  communication_not?: Int;
  communication_in?: Int[] | Int;
  communication_not_in?: Int[] | Int;
  communication_lt?: Int;
  communication_lte?: Int;
  communication_gt?: Int;
  communication_gte?: Int;
  place?: PlaceWhereInput;
  experience?: ExperienceWhereInput;
  AND?: ReviewWhereInput[] | ReviewWhereInput;
  OR?: ReviewWhereInput[] | ReviewWhereInput;
  NOT?: ReviewWhereInput[] | ReviewWhereInput;
}

export interface CityUpsertWithoutNeighbourhoodsInput {
  update: CityUpdateWithoutNeighbourhoodsDataInput;
  create: CityCreateWithoutNeighbourhoodsInput;
}

export interface NeighbourhoodCreateInput {
  locations?: LocationCreateManyWithoutNeighbourHoodInput;
  name: String;
  slug: String;
  homePreview?: PictureCreateOneInput;
  city: CityCreateOneWithoutNeighbourhoodsInput;
  featured: Boolean;
  popularity: Int;
}

export interface NeighbourhoodUpsertWithoutLocationsInput {
  update: NeighbourhoodUpdateWithoutLocationsDataInput;
  create: NeighbourhoodCreateWithoutLocationsInput;
}

export type RestaurantWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface UserUpdateOneWithoutLocationInput {
  create?: UserCreateWithoutLocationInput;
  update?: UserUpdateWithoutLocationDataInput;
  upsert?: UserUpsertWithoutLocationInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: UserWhereUniqueInput;
}

export interface LocationUpdateInput {
  lat?: Float;
  lng?: Float;
  neighbourHood?: NeighbourhoodUpdateOneWithoutLocationsInput;
  user?: UserUpdateOneWithoutLocationInput;
  place?: PlaceUpdateOneWithoutLocationInput;
  address?: String;
  directions?: String;
  experience?: ExperienceUpdateOneWithoutLocationInput;
  restaurant?: RestaurantUpdateOneWithoutLocationInput;
}

export interface UserUpdateWithoutLocationDataInput {
  firstName?: String;
  lastName?: String;
  email?: String;
  password?: String;
  phone?: String;
  responseRate?: Float;
  responseTime?: Int;
  isSuperHost?: Boolean;
  ownedPlaces?: PlaceUpdateManyWithoutHostInput;
  bookings?: BookingUpdateManyWithoutBookeeInput;
  paymentAccount?: PaymentAccountUpdateManyWithoutUserInput;
  sentMessages?: MessageUpdateManyWithoutFromInput;
  receivedMessages?: MessageUpdateManyWithoutToInput;
  notifications?: NotificationUpdateManyWithoutUserInput;
  profilePicture?: PictureUpdateOneInput;
  hostingExperiences?: ExperienceUpdateManyWithoutHostInput;
}

export interface HouseRulesUpdateInput {
  suitableForChildren?: Boolean;
  suitableForInfants?: Boolean;
  petsAllowed?: Boolean;
  smokingAllowed?: Boolean;
  partiesAndEventsAllowed?: Boolean;
  additionalRules?: String;
}

export interface BookingUpdateManyWithoutBookeeInput {
  create?: BookingCreateWithoutBookeeInput[] | BookingCreateWithoutBookeeInput;
  delete?: BookingWhereUniqueInput[] | BookingWhereUniqueInput;
  connect?: BookingWhereUniqueInput[] | BookingWhereUniqueInput;
  disconnect?: BookingWhereUniqueInput[] | BookingWhereUniqueInput;
  update?:
    | BookingUpdateWithWhereUniqueWithoutBookeeInput[]
    | BookingUpdateWithWhereUniqueWithoutBookeeInput;
  upsert?:
    | BookingUpsertWithWhereUniqueWithoutBookeeInput[]
    | BookingUpsertWithWhereUniqueWithoutBookeeInput;
}

export interface PlaceUpsertWithoutGuestRequirementsInput {
  update: PlaceUpdateWithoutGuestRequirementsDataInput;
  create: PlaceCreateWithoutGuestRequirementsInput;
}

export interface BookingUpdateWithWhereUniqueWithoutBookeeInput {
  where: BookingWhereUniqueInput;
  data: BookingUpdateWithoutBookeeDataInput;
}

export interface PlaceUpdateOneRequiredWithoutGuestRequirementsInput {
  create?: PlaceCreateWithoutGuestRequirementsInput;
  update?: PlaceUpdateWithoutGuestRequirementsDataInput;
  upsert?: PlaceUpsertWithoutGuestRequirementsInput;
  connect?: PlaceWhereUniqueInput;
}

export interface BookingUpdateWithoutBookeeDataInput {
  place?: PlaceUpdateOneRequiredWithoutBookingsInput;
  startDate?: DateTimeInput;
  endDate?: DateTimeInput;
  payment?: PaymentUpdateOneWithoutBookingInput;
}

export interface GuestRequirementsUpdateInput {
  govIssuedId?: Boolean;
  recommendationsFromOtherHosts?: Boolean;
  guestTripInformation?: Boolean;
  place?: PlaceUpdateOneRequiredWithoutGuestRequirementsInput;
}

export interface PlaceUpdateOneRequiredWithoutBookingsInput {
  create?: PlaceCreateWithoutBookingsInput;
  update?: PlaceUpdateWithoutBookingsDataInput;
  upsert?: PlaceUpsertWithoutBookingsInput;
  connect?: PlaceWhereUniqueInput;
}

export interface PlaceCreateOneWithoutGuestRequirementsInput {
  create?: PlaceCreateWithoutGuestRequirementsInput;
  connect?: PlaceWhereUniqueInput;
}

export interface PlaceUpdateWithoutBookingsDataInput {
  name?: String;
  size?: PLACE_SIZES;
  shortDescription?: String;
  description?: String;
  slug?: String;
  maxGuests?: Int;
  numBedrooms?: Int;
  numBeds?: Int;
  numBaths?: Int;
  reviews?: ReviewUpdateManyWithoutPlaceInput;
  amenities?: AmenitiesUpdateOneRequiredWithoutPlaceInput;
  host?: UserUpdateOneRequiredWithoutOwnedPlacesInput;
  pricing?: PricingUpdateOneRequiredWithoutPlaceInput;
  location?: LocationUpdateOneRequiredWithoutPlaceInput;
  views?: ViewsUpdateOneRequiredWithoutPlaceInput;
  guestRequirements?: GuestRequirementsUpdateOneWithoutPlaceInput;
  policies?: PoliciesUpdateOneWithoutPlaceInput;
  houseRules?: HouseRulesUpdateOneInput;
  pictures?: PictureUpdateManyInput;
  popularity?: Int;
}

export type ViewsWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface UserUpdateOneRequiredWithoutOwnedPlacesInput {
  create?: UserCreateWithoutOwnedPlacesInput;
  update?: UserUpdateWithoutOwnedPlacesDataInput;
  upsert?: UserUpsertWithoutOwnedPlacesInput;
  connect?: UserWhereUniqueInput;
}

export interface ExperienceUpdateWithoutCategoryDataInput {
  title?: String;
  host?: UserUpdateOneRequiredWithoutHostingExperiencesInput;
  location?: LocationUpdateOneRequiredWithoutExperienceInput;
  pricePerPerson?: Int;
  reviews?: ReviewUpdateManyWithoutExperienceInput;
  preview?: PictureUpdateOneRequiredInput;
  popularity?: Int;
}

export interface UserUpdateWithoutOwnedPlacesDataInput {
  firstName?: String;
  lastName?: String;
  email?: String;
  password?: String;
  phone?: String;
  responseRate?: Float;
  responseTime?: Int;
  isSuperHost?: Boolean;
  location?: LocationUpdateOneWithoutUserInput;
  bookings?: BookingUpdateManyWithoutBookeeInput;
  paymentAccount?: PaymentAccountUpdateManyWithoutUserInput;
  sentMessages?: MessageUpdateManyWithoutFromInput;
  receivedMessages?: MessageUpdateManyWithoutToInput;
  notifications?: NotificationUpdateManyWithoutUserInput;
  profilePicture?: PictureUpdateOneInput;
  hostingExperiences?: ExperienceUpdateManyWithoutHostInput;
}

export interface ExperienceCategoryUpdateInput {
  mainColor?: String;
  name?: String;
  experience?: ExperienceUpdateOneWithoutCategoryInput;
}

export interface NotificationWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  type?: NOTIFICATION_TYPE;
  type_not?: NOTIFICATION_TYPE;
  type_in?: NOTIFICATION_TYPE[] | NOTIFICATION_TYPE;
  type_not_in?: NOTIFICATION_TYPE[] | NOTIFICATION_TYPE;
  user?: UserWhereInput;
  link?: String;
  link_not?: String;
  link_in?: String[] | String;
  link_not_in?: String[] | String;
  link_lt?: String;
  link_lte?: String;
  link_gt?: String;
  link_gte?: String;
  link_contains?: String;
  link_not_contains?: String;
  link_starts_with?: String;
  link_not_starts_with?: String;
  link_ends_with?: String;
  link_not_ends_with?: String;
  readDate?: DateTimeInput;
  readDate_not?: DateTimeInput;
  readDate_in?: DateTimeInput[] | DateTimeInput;
  readDate_not_in?: DateTimeInput[] | DateTimeInput;
  readDate_lt?: DateTimeInput;
  readDate_lte?: DateTimeInput;
  readDate_gt?: DateTimeInput;
  readDate_gte?: DateTimeInput;
  AND?: NotificationWhereInput[] | NotificationWhereInput;
  OR?: NotificationWhereInput[] | NotificationWhereInput;
  NOT?: NotificationWhereInput[] | NotificationWhereInput;
}

export interface AmenitiesCreateInput {
  place: PlaceCreateOneWithoutAmenitiesInput;
  elevator?: Boolean;
  petsAllowed?: Boolean;
  internet?: Boolean;
  kitchen?: Boolean;
  wirelessInternet?: Boolean;
  familyKidFriendly?: Boolean;
  freeParkingOnPremises?: Boolean;
  hotTub?: Boolean;
  pool?: Boolean;
  smokingAllowed?: Boolean;
  wheelchairAccessible?: Boolean;
  breakfast?: Boolean;
  cableTv?: Boolean;
  suitableForEvents?: Boolean;
  dryer?: Boolean;
  washer?: Boolean;
  indoorFireplace?: Boolean;
  tv?: Boolean;
  heating?: Boolean;
  hangers?: Boolean;
  iron?: Boolean;
  hairDryer?: Boolean;
  doorman?: Boolean;
  paidParkingOffPremises?: Boolean;
  freeParkingOnStreet?: Boolean;
  gym?: Boolean;
  airConditioning?: Boolean;
  shampoo?: Boolean;
  essentials?: Boolean;
  laptopFriendlyWorkspace?: Boolean;
  privateEntrance?: Boolean;
  buzzerWirelessIntercom?: Boolean;
  babyBath?: Boolean;
  babyMonitor?: Boolean;
  babysitterRecommendations?: Boolean;
  bathtub?: Boolean;
  changingTable?: Boolean;
  childrensBooksAndToys?: Boolean;
  childrensDinnerware?: Boolean;
  crib?: Boolean;
}

export interface GuestRequirementsWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  govIssuedId?: Boolean;
  govIssuedId_not?: Boolean;
  recommendationsFromOtherHosts?: Boolean;
  recommendationsFromOtherHosts_not?: Boolean;
  guestTripInformation?: Boolean;
  guestTripInformation_not?: Boolean;
  place?: PlaceWhereInput;
  AND?: GuestRequirementsWhereInput[] | GuestRequirementsWhereInput;
  OR?: GuestRequirementsWhereInput[] | GuestRequirementsWhereInput;
  NOT?: GuestRequirementsWhereInput[] | GuestRequirementsWhereInput;
}

export interface PlaceCreateWithoutAmenitiesInput {
  name: String;
  size?: PLACE_SIZES;
  shortDescription: String;
  description: String;
  slug: String;
  maxGuests: Int;
  numBedrooms: Int;
  numBeds: Int;
  numBaths: Int;
  reviews?: ReviewCreateManyWithoutPlaceInput;
  host: UserCreateOneWithoutOwnedPlacesInput;
  pricing: PricingCreateOneWithoutPlaceInput;
  location: LocationCreateOneWithoutPlaceInput;
  views: ViewsCreateOneWithoutPlaceInput;
  guestRequirements?: GuestRequirementsCreateOneWithoutPlaceInput;
  policies?: PoliciesCreateOneWithoutPlaceInput;
  houseRules?: HouseRulesCreateOneInput;
  bookings?: BookingCreateManyWithoutPlaceInput;
  pictures?: PictureCreateManyInput;
  popularity: Int;
}

export interface HouseRulesWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  suitableForChildren?: Boolean;
  suitableForChildren_not?: Boolean;
  suitableForInfants?: Boolean;
  suitableForInfants_not?: Boolean;
  petsAllowed?: Boolean;
  petsAllowed_not?: Boolean;
  smokingAllowed?: Boolean;
  smokingAllowed_not?: Boolean;
  partiesAndEventsAllowed?: Boolean;
  partiesAndEventsAllowed_not?: Boolean;
  additionalRules?: String;
  additionalRules_not?: String;
  additionalRules_in?: String[] | String;
  additionalRules_not_in?: String[] | String;
  additionalRules_lt?: String;
  additionalRules_lte?: String;
  additionalRules_gt?: String;
  additionalRules_gte?: String;
  additionalRules_contains?: String;
  additionalRules_not_contains?: String;
  additionalRules_starts_with?: String;
  additionalRules_not_starts_with?: String;
  additionalRules_ends_with?: String;
  additionalRules_not_ends_with?: String;
  AND?: HouseRulesWhereInput[] | HouseRulesWhereInput;
  OR?: HouseRulesWhereInput[] | HouseRulesWhereInput;
  NOT?: HouseRulesWhereInput[] | HouseRulesWhereInput;
}

export interface ReviewCreateWithoutPlaceInput {
  text: String;
  stars: Int;
  accuracy: Int;
  location: Int;
  checkIn: Int;
  value: Int;
  cleanliness: Int;
  communication: Int;
  experience?: ExperienceCreateOneWithoutReviewsInput;
}

export interface ExperienceCreateOneWithoutCategoryInput {
  create?: ExperienceCreateWithoutCategoryInput;
  connect?: ExperienceWhereUniqueInput;
}

export interface ExperienceCreateWithoutReviewsInput {
  category?: ExperienceCategoryCreateOneWithoutExperienceInput;
  title: String;
  host: UserCreateOneWithoutHostingExperiencesInput;
  location: LocationCreateOneWithoutExperienceInput;
  pricePerPerson: Int;
  preview: PictureCreateOneInput;
  popularity: Int;
}

export interface ExperienceCategoryCreateInput {
  mainColor?: String;
  name: String;
  experience?: ExperienceCreateOneWithoutCategoryInput;
}

export interface ExperienceCategoryCreateWithoutExperienceInput {
  mainColor?: String;
  name: String;
}

export interface ViewsUpdateWithoutPlaceDataInput {
  lastWeek?: Int;
}

export interface UserCreateWithoutHostingExperiencesInput {
  firstName: String;
  lastName: String;
  email: String;
  password: String;
  phone: String;
  responseRate?: Float;
  responseTime?: Int;
  isSuperHost?: Boolean;
  ownedPlaces?: PlaceCreateManyWithoutHostInput;
  location?: LocationCreateOneWithoutUserInput;
  bookings?: BookingCreateManyWithoutBookeeInput;
  paymentAccount?: PaymentAccountCreateManyWithoutUserInput;
  sentMessages?: MessageCreateManyWithoutFromInput;
  receivedMessages?: MessageCreateManyWithoutToInput;
  notifications?: NotificationCreateManyWithoutUserInput;
  profilePicture?: PictureCreateOneInput;
}

export interface ViewsUpsertWithoutPlaceInput {
  update: ViewsUpdateWithoutPlaceDataInput;
  create: ViewsCreateWithoutPlaceInput;
}

export interface PlaceCreateWithoutHostInput {
  name: String;
  size?: PLACE_SIZES;
  shortDescription: String;
  description: String;
  slug: String;
  maxGuests: Int;
  numBedrooms: Int;
  numBeds: Int;
  numBaths: Int;
  reviews?: ReviewCreateManyWithoutPlaceInput;
  amenities: AmenitiesCreateOneWithoutPlaceInput;
  pricing: PricingCreateOneWithoutPlaceInput;
  location: LocationCreateOneWithoutPlaceInput;
  views: ViewsCreateOneWithoutPlaceInput;
  guestRequirements?: GuestRequirementsCreateOneWithoutPlaceInput;
  policies?: PoliciesCreateOneWithoutPlaceInput;
  houseRules?: HouseRulesCreateOneInput;
  bookings?: BookingCreateManyWithoutPlaceInput;
  pictures?: PictureCreateManyInput;
  popularity: Int;
}

export interface GuestRequirementsUpdateOneWithoutPlaceInput {
  create?: GuestRequirementsCreateWithoutPlaceInput;
  update?: GuestRequirementsUpdateWithoutPlaceDataInput;
  upsert?: GuestRequirementsUpsertWithoutPlaceInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: GuestRequirementsWhereUniqueInput;
}

export interface AmenitiesCreateWithoutPlaceInput {
  elevator?: Boolean;
  petsAllowed?: Boolean;
  internet?: Boolean;
  kitchen?: Boolean;
  wirelessInternet?: Boolean;
  familyKidFriendly?: Boolean;
  freeParkingOnPremises?: Boolean;
  hotTub?: Boolean;
  pool?: Boolean;
  smokingAllowed?: Boolean;
  wheelchairAccessible?: Boolean;
  breakfast?: Boolean;
  cableTv?: Boolean;
  suitableForEvents?: Boolean;
  dryer?: Boolean;
  washer?: Boolean;
  indoorFireplace?: Boolean;
  tv?: Boolean;
  heating?: Boolean;
  hangers?: Boolean;
  iron?: Boolean;
  hairDryer?: Boolean;
  doorman?: Boolean;
  paidParkingOffPremises?: Boolean;
  freeParkingOnStreet?: Boolean;
  gym?: Boolean;
  airConditioning?: Boolean;
  shampoo?: Boolean;
  essentials?: Boolean;
  laptopFriendlyWorkspace?: Boolean;
  privateEntrance?: Boolean;
  buzzerWirelessIntercom?: Boolean;
  babyBath?: Boolean;
  babyMonitor?: Boolean;
  babysitterRecommendations?: Boolean;
  bathtub?: Boolean;
  changingTable?: Boolean;
  childrensBooksAndToys?: Boolean;
  childrensDinnerware?: Boolean;
  crib?: Boolean;
}

export interface GuestRequirementsUpdateWithoutPlaceDataInput {
  govIssuedId?: Boolean;
  recommendationsFromOtherHosts?: Boolean;
  guestTripInformation?: Boolean;
}

export interface PricingCreateWithoutPlaceInput {
  monthlyDiscount?: Int;
  weeklyDiscount?: Int;
  perNight: Int;
  smartPricing?: Boolean;
  basePrice: Int;
  averageWeekly: Int;
  averageMonthly: Int;
  cleaningFee?: Int;
  securityDeposit?: Int;
  extraGuests?: Int;
  weekendPricing?: Int;
  currency?: CURRENCY;
}

export interface GuestRequirementsUpsertWithoutPlaceInput {
  update: GuestRequirementsUpdateWithoutPlaceDataInput;
  create: GuestRequirementsCreateWithoutPlaceInput;
}

export interface LocationCreateWithoutPlaceInput {
  lat: Float;
  lng: Float;
  neighbourHood?: NeighbourhoodCreateOneWithoutLocationsInput;
  user?: UserCreateOneWithoutLocationInput;
  address: String;
  directions: String;
  experience?: ExperienceCreateOneWithoutLocationInput;
  restaurant?: RestaurantCreateOneWithoutLocationInput;
}

export interface PoliciesUpdateOneWithoutPlaceInput {
  create?: PoliciesCreateWithoutPlaceInput;
  update?: PoliciesUpdateWithoutPlaceDataInput;
  upsert?: PoliciesUpsertWithoutPlaceInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: PoliciesWhereUniqueInput;
}

export interface NeighbourhoodCreateWithoutLocationsInput {
  name: String;
  slug: String;
  homePreview?: PictureCreateOneInput;
  city: CityCreateOneWithoutNeighbourhoodsInput;
  featured: Boolean;
  popularity: Int;
}

export interface PoliciesUpdateWithoutPlaceDataInput {
  checkInStartTime?: Float;
  checkInEndTime?: Float;
  checkoutTime?: Float;
}

export interface PictureCreateInput {
  url: String;
}

export interface PoliciesUpsertWithoutPlaceInput {
  update: PoliciesUpdateWithoutPlaceDataInput;
  create: PoliciesCreateWithoutPlaceInput;
}

export interface CityCreateWithoutNeighbourhoodsInput {
  name: String;
}

export interface HouseRulesUpdateOneInput {
  create?: HouseRulesCreateInput;
  update?: HouseRulesUpdateDataInput;
  upsert?: HouseRulesUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: HouseRulesWhereUniqueInput;
}

export interface UserCreateWithoutLocationInput {
  firstName: String;
  lastName: String;
  email: String;
  password: String;
  phone: String;
  responseRate?: Float;
  responseTime?: Int;
  isSuperHost?: Boolean;
  ownedPlaces?: PlaceCreateManyWithoutHostInput;
  bookings?: BookingCreateManyWithoutBookeeInput;
  paymentAccount?: PaymentAccountCreateManyWithoutUserInput;
  sentMessages?: MessageCreateManyWithoutFromInput;
  receivedMessages?: MessageCreateManyWithoutToInput;
  notifications?: NotificationCreateManyWithoutUserInput;
  profilePicture?: PictureCreateOneInput;
  hostingExperiences?: ExperienceCreateManyWithoutHostInput;
}

export interface HouseRulesUpdateDataInput {
  suitableForChildren?: Boolean;
  suitableForInfants?: Boolean;
  petsAllowed?: Boolean;
  smokingAllowed?: Boolean;
  partiesAndEventsAllowed?: Boolean;
  additionalRules?: String;
}

export interface BookingCreateWithoutBookeeInput {
  place: PlaceCreateOneWithoutBookingsInput;
  startDate: DateTimeInput;
  endDate: DateTimeInput;
  payment?: PaymentCreateOneWithoutBookingInput;
}

export interface HouseRulesUpsertNestedInput {
  update: HouseRulesUpdateDataInput;
  create: HouseRulesCreateInput;
}

export interface PlaceCreateWithoutBookingsInput {
  name: String;
  size?: PLACE_SIZES;
  shortDescription: String;
  description: String;
  slug: String;
  maxGuests: Int;
  numBedrooms: Int;
  numBeds: Int;
  numBaths: Int;
  reviews?: ReviewCreateManyWithoutPlaceInput;
  amenities: AmenitiesCreateOneWithoutPlaceInput;
  host: UserCreateOneWithoutOwnedPlacesInput;
  pricing: PricingCreateOneWithoutPlaceInput;
  location: LocationCreateOneWithoutPlaceInput;
  views: ViewsCreateOneWithoutPlaceInput;
  guestRequirements?: GuestRequirementsCreateOneWithoutPlaceInput;
  policies?: PoliciesCreateOneWithoutPlaceInput;
  houseRules?: HouseRulesCreateOneInput;
  pictures?: PictureCreateManyInput;
  popularity: Int;
}

export interface BookingUpdateManyWithoutPlaceInput {
  create?: BookingCreateWithoutPlaceInput[] | BookingCreateWithoutPlaceInput;
  delete?: BookingWhereUniqueInput[] | BookingWhereUniqueInput;
  connect?: BookingWhereUniqueInput[] | BookingWhereUniqueInput;
  disconnect?: BookingWhereUniqueInput[] | BookingWhereUniqueInput;
  update?:
    | BookingUpdateWithWhereUniqueWithoutPlaceInput[]
    | BookingUpdateWithWhereUniqueWithoutPlaceInput;
  upsert?:
    | BookingUpsertWithWhereUniqueWithoutPlaceInput[]
    | BookingUpsertWithWhereUniqueWithoutPlaceInput;
}

export interface UserCreateWithoutOwnedPlacesInput {
  firstName: String;
  lastName: String;
  email: String;
  password: String;
  phone: String;
  responseRate?: Float;
  responseTime?: Int;
  isSuperHost?: Boolean;
  location?: LocationCreateOneWithoutUserInput;
  bookings?: BookingCreateManyWithoutBookeeInput;
  paymentAccount?: PaymentAccountCreateManyWithoutUserInput;
  sentMessages?: MessageCreateManyWithoutFromInput;
  receivedMessages?: MessageCreateManyWithoutToInput;
  notifications?: NotificationCreateManyWithoutUserInput;
  profilePicture?: PictureCreateOneInput;
  hostingExperiences?: ExperienceCreateManyWithoutHostInput;
}

export interface BookingUpdateWithWhereUniqueWithoutPlaceInput {
  where: BookingWhereUniqueInput;
  data: BookingUpdateWithoutPlaceDataInput;
}

export interface LocationCreateWithoutUserInput {
  lat: Float;
  lng: Float;
  neighbourHood?: NeighbourhoodCreateOneWithoutLocationsInput;
  place?: PlaceCreateOneWithoutLocationInput;
  address: String;
  directions: String;
  experience?: ExperienceCreateOneWithoutLocationInput;
  restaurant?: RestaurantCreateOneWithoutLocationInput;
}

export interface BookingUpdateWithoutPlaceDataInput {
  bookee?: UserUpdateOneRequiredWithoutBookingsInput;
  startDate?: DateTimeInput;
  endDate?: DateTimeInput;
  payment?: PaymentUpdateOneWithoutBookingInput;
}

export interface PlaceCreateWithoutLocationInput {
  name: String;
  size?: PLACE_SIZES;
  shortDescription: String;
  description: String;
  slug: String;
  maxGuests: Int;
  numBedrooms: Int;
  numBeds: Int;
  numBaths: Int;
  reviews?: ReviewCreateManyWithoutPlaceInput;
  amenities: AmenitiesCreateOneWithoutPlaceInput;
  host: UserCreateOneWithoutOwnedPlacesInput;
  pricing: PricingCreateOneWithoutPlaceInput;
  views: ViewsCreateOneWithoutPlaceInput;
  guestRequirements?: GuestRequirementsCreateOneWithoutPlaceInput;
  policies?: PoliciesCreateOneWithoutPlaceInput;
  houseRules?: HouseRulesCreateOneInput;
  bookings?: BookingCreateManyWithoutPlaceInput;
  pictures?: PictureCreateManyInput;
  popularity: Int;
}

export interface UserUpdateOneRequiredWithoutBookingsInput {
  create?: UserCreateWithoutBookingsInput;
  update?: UserUpdateWithoutBookingsDataInput;
  upsert?: UserUpsertWithoutBookingsInput;
  connect?: UserWhereUniqueInput;
}

export interface ViewsCreateWithoutPlaceInput {
  lastWeek: Int;
}

export interface UserUpdateWithoutBookingsDataInput {
  firstName?: String;
  lastName?: String;
  email?: String;
  password?: String;
  phone?: String;
  responseRate?: Float;
  responseTime?: Int;
  isSuperHost?: Boolean;
  ownedPlaces?: PlaceUpdateManyWithoutHostInput;
  location?: LocationUpdateOneWithoutUserInput;
  paymentAccount?: PaymentAccountUpdateManyWithoutUserInput;
  sentMessages?: MessageUpdateManyWithoutFromInput;
  receivedMessages?: MessageUpdateManyWithoutToInput;
  notifications?: NotificationUpdateManyWithoutUserInput;
  profilePicture?: PictureUpdateOneInput;
  hostingExperiences?: ExperienceUpdateManyWithoutHostInput;
}

export interface GuestRequirementsCreateWithoutPlaceInput {
  govIssuedId?: Boolean;
  recommendationsFromOtherHosts?: Boolean;
  guestTripInformation?: Boolean;
}

export interface PaymentAccountUpdateManyWithoutUserInput {
  create?:
    | PaymentAccountCreateWithoutUserInput[]
    | PaymentAccountCreateWithoutUserInput;
  delete?: PaymentAccountWhereUniqueInput[] | PaymentAccountWhereUniqueInput;
  connect?: PaymentAccountWhereUniqueInput[] | PaymentAccountWhereUniqueInput;
  disconnect?:
    | PaymentAccountWhereUniqueInput[]
    | PaymentAccountWhereUniqueInput;
  update?:
    | PaymentAccountUpdateWithWhereUniqueWithoutUserInput[]
    | PaymentAccountUpdateWithWhereUniqueWithoutUserInput;
  upsert?:
    | PaymentAccountUpsertWithWhereUniqueWithoutUserInput[]
    | PaymentAccountUpsertWithWhereUniqueWithoutUserInput;
}

export interface PoliciesCreateWithoutPlaceInput {
  checkInStartTime: Float;
  checkInEndTime: Float;
  checkoutTime: Float;
}

export interface PaymentAccountUpdateWithWhereUniqueWithoutUserInput {
  where: PaymentAccountWhereUniqueInput;
  data: PaymentAccountUpdateWithoutUserDataInput;
}

export interface HouseRulesCreateInput {
  suitableForChildren?: Boolean;
  suitableForInfants?: Boolean;
  petsAllowed?: Boolean;
  smokingAllowed?: Boolean;
  partiesAndEventsAllowed?: Boolean;
  additionalRules?: String;
}

export interface PaymentAccountUpdateWithoutUserDataInput {
  type?: PAYMENT_PROVIDER;
  payments?: PaymentUpdateManyWithoutPaymentMethodInput;
  paypal?: PaypalInformationUpdateOneWithoutPaymentAccountInput;
  creditcard?: CreditCardInformationUpdateOneWithoutPaymentAccountInput;
}

export interface BookingCreateWithoutPlaceInput {
  bookee: UserCreateOneWithoutBookingsInput;
  startDate: DateTimeInput;
  endDate: DateTimeInput;
  payment?: PaymentCreateOneWithoutBookingInput;
}

export interface PaymentUpdateManyWithoutPaymentMethodInput {
  create?:
    | PaymentCreateWithoutPaymentMethodInput[]
    | PaymentCreateWithoutPaymentMethodInput;
  delete?: PaymentWhereUniqueInput[] | PaymentWhereUniqueInput;
  connect?: PaymentWhereUniqueInput[] | PaymentWhereUniqueInput;
  disconnect?: PaymentWhereUniqueInput[] | PaymentWhereUniqueInput;
  update?:
    | PaymentUpdateWithWhereUniqueWithoutPaymentMethodInput[]
    | PaymentUpdateWithWhereUniqueWithoutPaymentMethodInput;
  upsert?:
    | PaymentUpsertWithWhereUniqueWithoutPaymentMethodInput[]
    | PaymentUpsertWithWhereUniqueWithoutPaymentMethodInput;
}

export interface UserCreateWithoutBookingsInput {
  firstName: String;
  lastName: String;
  email: String;
  password: String;
  phone: String;
  responseRate?: Float;
  responseTime?: Int;
  isSuperHost?: Boolean;
  ownedPlaces?: PlaceCreateManyWithoutHostInput;
  location?: LocationCreateOneWithoutUserInput;
  paymentAccount?: PaymentAccountCreateManyWithoutUserInput;
  sentMessages?: MessageCreateManyWithoutFromInput;
  receivedMessages?: MessageCreateManyWithoutToInput;
  notifications?: NotificationCreateManyWithoutUserInput;
  profilePicture?: PictureCreateOneInput;
  hostingExperiences?: ExperienceCreateManyWithoutHostInput;
}

export interface PaymentUpdateWithWhereUniqueWithoutPaymentMethodInput {
  where: PaymentWhereUniqueInput;
  data: PaymentUpdateWithoutPaymentMethodDataInput;
}

export interface PaymentAccountCreateWithoutUserInput {
  type?: PAYMENT_PROVIDER;
  payments?: PaymentCreateManyWithoutPaymentMethodInput;
  paypal?: PaypalInformationCreateOneWithoutPaymentAccountInput;
  creditcard?: CreditCardInformationCreateOneWithoutPaymentAccountInput;
}

export interface PaymentUpdateWithoutPaymentMethodDataInput {
  serviceFee?: Float;
  placePrice?: Float;
  totalPrice?: Float;
  booking?: BookingUpdateOneRequiredWithoutPaymentInput;
}

export interface PaymentCreateWithoutPaymentMethodInput {
  serviceFee: Float;
  placePrice: Float;
  totalPrice: Float;
  booking: BookingCreateOneWithoutPaymentInput;
}

export interface BookingUpdateOneRequiredWithoutPaymentInput {
  create?: BookingCreateWithoutPaymentInput;
  update?: BookingUpdateWithoutPaymentDataInput;
  upsert?: BookingUpsertWithoutPaymentInput;
  connect?: BookingWhereUniqueInput;
}

export interface BookingCreateWithoutPaymentInput {
  bookee: UserCreateOneWithoutBookingsInput;
  place: PlaceCreateOneWithoutBookingsInput;
  startDate: DateTimeInput;
  endDate: DateTimeInput;
}

export interface BookingUpdateWithoutPaymentDataInput {
  bookee?: UserUpdateOneRequiredWithoutBookingsInput;
  place?: PlaceUpdateOneRequiredWithoutBookingsInput;
  startDate?: DateTimeInput;
  endDate?: DateTimeInput;
}

export interface PaypalInformationCreateWithoutPaymentAccountInput {
  email: String;
}

export interface BookingUpsertWithoutPaymentInput {
  update: BookingUpdateWithoutPaymentDataInput;
  create: BookingCreateWithoutPaymentInput;
}

export interface CreditCardInformationCreateWithoutPaymentAccountInput {
  cardNumber: String;
  expiresOnMonth: Int;
  expiresOnYear: Int;
  securityCode: String;
  firstName: String;
  lastName: String;
  postalCode: String;
  country: String;
}

export interface PaymentUpsertWithWhereUniqueWithoutPaymentMethodInput {
  where: PaymentWhereUniqueInput;
  update: PaymentUpdateWithoutPaymentMethodDataInput;
  create: PaymentCreateWithoutPaymentMethodInput;
}

export interface MessageCreateWithoutFromInput {
  to: UserCreateOneWithoutReceivedMessagesInput;
  deliveredAt: DateTimeInput;
  readAt: DateTimeInput;
}

export interface PaypalInformationUpdateOneWithoutPaymentAccountInput {
  create?: PaypalInformationCreateWithoutPaymentAccountInput;
  update?: PaypalInformationUpdateWithoutPaymentAccountDataInput;
  upsert?: PaypalInformationUpsertWithoutPaymentAccountInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: PaypalInformationWhereUniqueInput;
}

export interface ViewsSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ViewsWhereInput;
  AND?: ViewsSubscriptionWhereInput[] | ViewsSubscriptionWhereInput;
  OR?: ViewsSubscriptionWhereInput[] | ViewsSubscriptionWhereInput;
  NOT?: ViewsSubscriptionWhereInput[] | ViewsSubscriptionWhereInput;
}

export interface PaypalInformationUpdateWithoutPaymentAccountDataInput {
  email?: String;
}

export interface PaypalInformationWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  paymentAccount?: PaymentAccountWhereInput;
  AND?: PaypalInformationWhereInput[] | PaypalInformationWhereInput;
  OR?: PaypalInformationWhereInput[] | PaypalInformationWhereInput;
  NOT?: PaypalInformationWhereInput[] | PaypalInformationWhereInput;
}

export interface PaypalInformationUpsertWithoutPaymentAccountInput {
  update: PaypalInformationUpdateWithoutPaymentAccountDataInput;
  create: PaypalInformationCreateWithoutPaymentAccountInput;
}

export interface PoliciesSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PoliciesWhereInput;
  AND?: PoliciesSubscriptionWhereInput[] | PoliciesSubscriptionWhereInput;
  OR?: PoliciesSubscriptionWhereInput[] | PoliciesSubscriptionWhereInput;
  NOT?: PoliciesSubscriptionWhereInput[] | PoliciesSubscriptionWhereInput;
}

export interface CreditCardInformationUpdateOneWithoutPaymentAccountInput {
  create?: CreditCardInformationCreateWithoutPaymentAccountInput;
  update?: CreditCardInformationUpdateWithoutPaymentAccountDataInput;
  upsert?: CreditCardInformationUpsertWithoutPaymentAccountInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: CreditCardInformationWhereUniqueInput;
}

export interface PictureSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PictureWhereInput;
  AND?: PictureSubscriptionWhereInput[] | PictureSubscriptionWhereInput;
  OR?: PictureSubscriptionWhereInput[] | PictureSubscriptionWhereInput;
  NOT?: PictureSubscriptionWhereInput[] | PictureSubscriptionWhereInput;
}

export interface CreditCardInformationUpdateWithoutPaymentAccountDataInput {
  cardNumber?: String;
  expiresOnMonth?: Int;
  expiresOnYear?: Int;
  securityCode?: String;
  firstName?: String;
  lastName?: String;
  postalCode?: String;
  country?: String;
}

export interface PaymentSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PaymentWhereInput;
  AND?: PaymentSubscriptionWhereInput[] | PaymentSubscriptionWhereInput;
  OR?: PaymentSubscriptionWhereInput[] | PaymentSubscriptionWhereInput;
  NOT?: PaymentSubscriptionWhereInput[] | PaymentSubscriptionWhereInput;
}

export interface CreditCardInformationUpsertWithoutPaymentAccountInput {
  update: CreditCardInformationUpdateWithoutPaymentAccountDataInput;
  create: CreditCardInformationCreateWithoutPaymentAccountInput;
}

export interface CityWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  neighbourhoods_every?: NeighbourhoodWhereInput;
  neighbourhoods_some?: NeighbourhoodWhereInput;
  neighbourhoods_none?: NeighbourhoodWhereInput;
  AND?: CityWhereInput[] | CityWhereInput;
  OR?: CityWhereInput[] | CityWhereInput;
  NOT?: CityWhereInput[] | CityWhereInput;
}

export interface PaymentAccountUpsertWithWhereUniqueWithoutUserInput {
  where: PaymentAccountWhereUniqueInput;
  update: PaymentAccountUpdateWithoutUserDataInput;
  create: PaymentAccountCreateWithoutUserInput;
}

export interface LocationSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: LocationWhereInput;
  AND?: LocationSubscriptionWhereInput[] | LocationSubscriptionWhereInput;
  OR?: LocationSubscriptionWhereInput[] | LocationSubscriptionWhereInput;
  NOT?: LocationSubscriptionWhereInput[] | LocationSubscriptionWhereInput;
}

export interface MessageUpdateManyWithoutFromInput {
  create?: MessageCreateWithoutFromInput[] | MessageCreateWithoutFromInput;
  delete?: MessageWhereUniqueInput[] | MessageWhereUniqueInput;
  connect?: MessageWhereUniqueInput[] | MessageWhereUniqueInput;
  disconnect?: MessageWhereUniqueInput[] | MessageWhereUniqueInput;
  update?:
    | MessageUpdateWithWhereUniqueWithoutFromInput[]
    | MessageUpdateWithWhereUniqueWithoutFromInput;
  upsert?:
    | MessageUpsertWithWhereUniqueWithoutFromInput[]
    | MessageUpsertWithWhereUniqueWithoutFromInput;
}

export interface NeighbourhoodWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  locations_every?: LocationWhereInput;
  locations_some?: LocationWhereInput;
  locations_none?: LocationWhereInput;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  slug?: String;
  slug_not?: String;
  slug_in?: String[] | String;
  slug_not_in?: String[] | String;
  slug_lt?: String;
  slug_lte?: String;
  slug_gt?: String;
  slug_gte?: String;
  slug_contains?: String;
  slug_not_contains?: String;
  slug_starts_with?: String;
  slug_not_starts_with?: String;
  slug_ends_with?: String;
  slug_not_ends_with?: String;
  homePreview?: PictureWhereInput;
  city?: CityWhereInput;
  featured?: Boolean;
  featured_not?: Boolean;
  popularity?: Int;
  popularity_not?: Int;
  popularity_in?: Int[] | Int;
  popularity_not_in?: Int[] | Int;
  popularity_lt?: Int;
  popularity_lte?: Int;
  popularity_gt?: Int;
  popularity_gte?: Int;
  AND?: NeighbourhoodWhereInput[] | NeighbourhoodWhereInput;
  OR?: NeighbourhoodWhereInput[] | NeighbourhoodWhereInput;
  NOT?: NeighbourhoodWhereInput[] | NeighbourhoodWhereInput;
}

export interface MessageUpdateWithWhereUniqueWithoutFromInput {
  where: MessageWhereUniqueInput;
  data: MessageUpdateWithoutFromDataInput;
}

export interface BookingSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: BookingWhereInput;
  AND?: BookingSubscriptionWhereInput[] | BookingSubscriptionWhereInput;
  OR?: BookingSubscriptionWhereInput[] | BookingSubscriptionWhereInput;
  NOT?: BookingSubscriptionWhereInput[] | BookingSubscriptionWhereInput;
}

export interface MessageUpdateWithoutFromDataInput {
  to?: UserUpdateOneRequiredWithoutReceivedMessagesInput;
  deliveredAt?: DateTimeInput;
  readAt?: DateTimeInput;
}

export interface PlaceUpdateWithoutViewsDataInput {
  name?: String;
  size?: PLACE_SIZES;
  shortDescription?: String;
  description?: String;
  slug?: String;
  maxGuests?: Int;
  numBedrooms?: Int;
  numBeds?: Int;
  numBaths?: Int;
  reviews?: ReviewUpdateManyWithoutPlaceInput;
  amenities?: AmenitiesUpdateOneRequiredWithoutPlaceInput;
  host?: UserUpdateOneRequiredWithoutOwnedPlacesInput;
  pricing?: PricingUpdateOneRequiredWithoutPlaceInput;
  location?: LocationUpdateOneRequiredWithoutPlaceInput;
  guestRequirements?: GuestRequirementsUpdateOneWithoutPlaceInput;
  policies?: PoliciesUpdateOneWithoutPlaceInput;
  houseRules?: HouseRulesUpdateOneInput;
  bookings?: BookingUpdateManyWithoutPlaceInput;
  pictures?: PictureUpdateManyInput;
  popularity?: Int;
}

export interface UserUpdateOneRequiredWithoutReceivedMessagesInput {
  create?: UserCreateWithoutReceivedMessagesInput;
  update?: UserUpdateWithoutReceivedMessagesDataInput;
  upsert?: UserUpsertWithoutReceivedMessagesInput;
  connect?: UserWhereUniqueInput;
}

export interface ViewsUpdateInput {
  lastWeek?: Int;
  place?: PlaceUpdateOneRequiredWithoutViewsInput;
}

export interface UserUpdateWithoutReceivedMessagesDataInput {
  firstName?: String;
  lastName?: String;
  email?: String;
  password?: String;
  phone?: String;
  responseRate?: Float;
  responseTime?: Int;
  isSuperHost?: Boolean;
  ownedPlaces?: PlaceUpdateManyWithoutHostInput;
  location?: LocationUpdateOneWithoutUserInput;
  bookings?: BookingUpdateManyWithoutBookeeInput;
  paymentAccount?: PaymentAccountUpdateManyWithoutUserInput;
  sentMessages?: MessageUpdateManyWithoutFromInput;
  notifications?: NotificationUpdateManyWithoutUserInput;
  profilePicture?: PictureUpdateOneInput;
  hostingExperiences?: ExperienceUpdateManyWithoutHostInput;
}

export interface ViewsCreateInput {
  lastWeek: Int;
  place: PlaceCreateOneWithoutViewsInput;
}

export interface NotificationUpdateManyWithoutUserInput {
  create?:
    | NotificationCreateWithoutUserInput[]
    | NotificationCreateWithoutUserInput;
  delete?: NotificationWhereUniqueInput[] | NotificationWhereUniqueInput;
  connect?: NotificationWhereUniqueInput[] | NotificationWhereUniqueInput;
  disconnect?: NotificationWhereUniqueInput[] | NotificationWhereUniqueInput;
  update?:
    | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    | NotificationUpdateWithWhereUniqueWithoutUserInput;
  upsert?:
    | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    | NotificationUpsertWithWhereUniqueWithoutUserInput;
}

export interface ReviewUpdateInput {
  text?: String;
  stars?: Int;
  accuracy?: Int;
  location?: Int;
  checkIn?: Int;
  value?: Int;
  cleanliness?: Int;
  communication?: Int;
  place?: PlaceUpdateOneRequiredWithoutReviewsInput;
  experience?: ExperienceUpdateOneWithoutReviewsInput;
}

export interface NotificationUpdateWithWhereUniqueWithoutUserInput {
  where: NotificationWhereUniqueInput;
  data: NotificationUpdateWithoutUserDataInput;
}

export interface UserWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  firstName?: String;
  firstName_not?: String;
  firstName_in?: String[] | String;
  firstName_not_in?: String[] | String;
  firstName_lt?: String;
  firstName_lte?: String;
  firstName_gt?: String;
  firstName_gte?: String;
  firstName_contains?: String;
  firstName_not_contains?: String;
  firstName_starts_with?: String;
  firstName_not_starts_with?: String;
  firstName_ends_with?: String;
  firstName_not_ends_with?: String;
  lastName?: String;
  lastName_not?: String;
  lastName_in?: String[] | String;
  lastName_not_in?: String[] | String;
  lastName_lt?: String;
  lastName_lte?: String;
  lastName_gt?: String;
  lastName_gte?: String;
  lastName_contains?: String;
  lastName_not_contains?: String;
  lastName_starts_with?: String;
  lastName_not_starts_with?: String;
  lastName_ends_with?: String;
  lastName_not_ends_with?: String;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  phone?: String;
  phone_not?: String;
  phone_in?: String[] | String;
  phone_not_in?: String[] | String;
  phone_lt?: String;
  phone_lte?: String;
  phone_gt?: String;
  phone_gte?: String;
  phone_contains?: String;
  phone_not_contains?: String;
  phone_starts_with?: String;
  phone_not_starts_with?: String;
  phone_ends_with?: String;
  phone_not_ends_with?: String;
  responseRate?: Float;
  responseRate_not?: Float;
  responseRate_in?: Float[] | Float;
  responseRate_not_in?: Float[] | Float;
  responseRate_lt?: Float;
  responseRate_lte?: Float;
  responseRate_gt?: Float;
  responseRate_gte?: Float;
  responseTime?: Int;
  responseTime_not?: Int;
  responseTime_in?: Int[] | Int;
  responseTime_not_in?: Int[] | Int;
  responseTime_lt?: Int;
  responseTime_lte?: Int;
  responseTime_gt?: Int;
  responseTime_gte?: Int;
  isSuperHost?: Boolean;
  isSuperHost_not?: Boolean;
  ownedPlaces_every?: PlaceWhereInput;
  ownedPlaces_some?: PlaceWhereInput;
  ownedPlaces_none?: PlaceWhereInput;
  location?: LocationWhereInput;
  bookings_every?: BookingWhereInput;
  bookings_some?: BookingWhereInput;
  bookings_none?: BookingWhereInput;
  paymentAccount_every?: PaymentAccountWhereInput;
  paymentAccount_some?: PaymentAccountWhereInput;
  paymentAccount_none?: PaymentAccountWhereInput;
  sentMessages_every?: MessageWhereInput;
  sentMessages_some?: MessageWhereInput;
  sentMessages_none?: MessageWhereInput;
  receivedMessages_every?: MessageWhereInput;
  receivedMessages_some?: MessageWhereInput;
  receivedMessages_none?: MessageWhereInput;
  notifications_every?: NotificationWhereInput;
  notifications_some?: NotificationWhereInput;
  notifications_none?: NotificationWhereInput;
  profilePicture?: PictureWhereInput;
  hostingExperiences_every?: ExperienceWhereInput;
  hostingExperiences_some?: ExperienceWhereInput;
  hostingExperiences_none?: ExperienceWhereInput;
  AND?: UserWhereInput[] | UserWhereInput;
  OR?: UserWhereInput[] | UserWhereInput;
  NOT?: UserWhereInput[] | UserWhereInput;
}

export interface NotificationUpdateWithoutUserDataInput {
  type?: NOTIFICATION_TYPE;
  link?: String;
  readDate?: DateTimeInput;
}

export type GuestRequirementsWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface NotificationUpsertWithWhereUniqueWithoutUserInput {
  where: NotificationWhereUniqueInput;
  update: NotificationUpdateWithoutUserDataInput;
  create: NotificationCreateWithoutUserInput;
}

export interface PlaceUpsertWithoutPricingInput {
  update: PlaceUpdateWithoutPricingDataInput;
  create: PlaceCreateWithoutPricingInput;
}

export interface ExperienceUpdateManyWithoutHostInput {
  create?:
    | ExperienceCreateWithoutHostInput[]
    | ExperienceCreateWithoutHostInput;
  delete?: ExperienceWhereUniqueInput[] | ExperienceWhereUniqueInput;
  connect?: ExperienceWhereUniqueInput[] | ExperienceWhereUniqueInput;
  disconnect?: ExperienceWhereUniqueInput[] | ExperienceWhereUniqueInput;
  update?:
    | ExperienceUpdateWithWhereUniqueWithoutHostInput[]
    | ExperienceUpdateWithWhereUniqueWithoutHostInput;
  upsert?:
    | ExperienceUpsertWithWhereUniqueWithoutHostInput[]
    | ExperienceUpsertWithWhereUniqueWithoutHostInput;
}

export interface PlaceUpdateOneRequiredWithoutPricingInput {
  create?: PlaceCreateWithoutPricingInput;
  update?: PlaceUpdateWithoutPricingDataInput;
  upsert?: PlaceUpsertWithoutPricingInput;
  connect?: PlaceWhereUniqueInput;
}

export interface ExperienceUpdateWithWhereUniqueWithoutHostInput {
  where: ExperienceWhereUniqueInput;
  data: ExperienceUpdateWithoutHostDataInput;
}

export interface PlaceCreateOneWithoutPricingInput {
  create?: PlaceCreateWithoutPricingInput;
  connect?: PlaceWhereUniqueInput;
}

export interface ExperienceUpdateWithoutHostDataInput {
  category?: ExperienceCategoryUpdateOneWithoutExperienceInput;
  title?: String;
  location?: LocationUpdateOneRequiredWithoutExperienceInput;
  pricePerPerson?: Int;
  reviews?: ReviewUpdateManyWithoutExperienceInput;
  preview?: PictureUpdateOneRequiredInput;
  popularity?: Int;
}

export interface PlaceUpdateWithoutPoliciesDataInput {
  name?: String;
  size?: PLACE_SIZES;
  shortDescription?: String;
  description?: String;
  slug?: String;
  maxGuests?: Int;
  numBedrooms?: Int;
  numBeds?: Int;
  numBaths?: Int;
  reviews?: ReviewUpdateManyWithoutPlaceInput;
  amenities?: AmenitiesUpdateOneRequiredWithoutPlaceInput;
  host?: UserUpdateOneRequiredWithoutOwnedPlacesInput;
  pricing?: PricingUpdateOneRequiredWithoutPlaceInput;
  location?: LocationUpdateOneRequiredWithoutPlaceInput;
  views?: ViewsUpdateOneRequiredWithoutPlaceInput;
  guestRequirements?: GuestRequirementsUpdateOneWithoutPlaceInput;
  houseRules?: HouseRulesUpdateOneInput;
  bookings?: BookingUpdateManyWithoutPlaceInput;
  pictures?: PictureUpdateManyInput;
  popularity?: Int;
}

export interface LocationUpdateOneRequiredWithoutExperienceInput {
  create?: LocationCreateWithoutExperienceInput;
  update?: LocationUpdateWithoutExperienceDataInput;
  upsert?: LocationUpsertWithoutExperienceInput;
  connect?: LocationWhereUniqueInput;
}

export interface PlaceCreateWithoutPoliciesInput {
  name: String;
  size?: PLACE_SIZES;
  shortDescription: String;
  description: String;
  slug: String;
  maxGuests: Int;
  numBedrooms: Int;
  numBeds: Int;
  numBaths: Int;
  reviews?: ReviewCreateManyWithoutPlaceInput;
  amenities: AmenitiesCreateOneWithoutPlaceInput;
  host: UserCreateOneWithoutOwnedPlacesInput;
  pricing: PricingCreateOneWithoutPlaceInput;
  location: LocationCreateOneWithoutPlaceInput;
  views: ViewsCreateOneWithoutPlaceInput;
  guestRequirements?: GuestRequirementsCreateOneWithoutPlaceInput;
  houseRules?: HouseRulesCreateOneInput;
  bookings?: BookingCreateManyWithoutPlaceInput;
  pictures?: PictureCreateManyInput;
  popularity: Int;
}

export interface LocationUpdateWithoutExperienceDataInput {
  lat?: Float;
  lng?: Float;
  neighbourHood?: NeighbourhoodUpdateOneWithoutLocationsInput;
  user?: UserUpdateOneWithoutLocationInput;
  place?: PlaceUpdateOneWithoutLocationInput;
  address?: String;
  directions?: String;
  restaurant?: RestaurantUpdateOneWithoutLocationInput;
}

export interface PlaceUpdateInput {
  name?: String;
  size?: PLACE_SIZES;
  shortDescription?: String;
  description?: String;
  slug?: String;
  maxGuests?: Int;
  numBedrooms?: Int;
  numBeds?: Int;
  numBaths?: Int;
  reviews?: ReviewUpdateManyWithoutPlaceInput;
  amenities?: AmenitiesUpdateOneRequiredWithoutPlaceInput;
  host?: UserUpdateOneRequiredWithoutOwnedPlacesInput;
  pricing?: PricingUpdateOneRequiredWithoutPlaceInput;
  location?: LocationUpdateOneRequiredWithoutPlaceInput;
  views?: ViewsUpdateOneRequiredWithoutPlaceInput;
  guestRequirements?: GuestRequirementsUpdateOneWithoutPlaceInput;
  policies?: PoliciesUpdateOneWithoutPlaceInput;
  houseRules?: HouseRulesUpdateOneInput;
  bookings?: BookingUpdateManyWithoutPlaceInput;
  pictures?: PictureUpdateManyInput;
  popularity?: Int;
}

export interface RestaurantUpdateOneWithoutLocationInput {
  create?: RestaurantCreateWithoutLocationInput;
  update?: RestaurantUpdateWithoutLocationDataInput;
  upsert?: RestaurantUpsertWithoutLocationInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: RestaurantWhereUniqueInput;
}

export interface PaymentAccountUpsertWithoutPaypalInput {
  update: PaymentAccountUpdateWithoutPaypalDataInput;
  create: PaymentAccountCreateWithoutPaypalInput;
}

export interface RestaurantUpdateWithoutLocationDataInput {
  title?: String;
  avgPricePerPerson?: Int;
  pictures?: PictureUpdateManyInput;
  isCurated?: Boolean;
  slug?: String;
  popularity?: Int;
}

export interface PaypalInformationUpdateInput {
  email?: String;
  paymentAccount?: PaymentAccountUpdateOneRequiredWithoutPaypalInput;
}

export interface PictureUpdateManyInput {
  create?: PictureCreateInput[] | PictureCreateInput;
  update?:
    | PictureUpdateWithWhereUniqueNestedInput[]
    | PictureUpdateWithWhereUniqueNestedInput;
  upsert?:
    | PictureUpsertWithWhereUniqueNestedInput[]
    | PictureUpsertWithWhereUniqueNestedInput;
  delete?: PictureWhereUniqueInput[] | PictureWhereUniqueInput;
  connect?: PictureWhereUniqueInput[] | PictureWhereUniqueInput;
  disconnect?: PictureWhereUniqueInput[] | PictureWhereUniqueInput;
}

export interface PaymentAccountCreateOneWithoutPaypalInput {
  create?: PaymentAccountCreateWithoutPaypalInput;
  connect?: PaymentAccountWhereUniqueInput;
}

export interface PictureUpdateWithWhereUniqueNestedInput {
  where: PictureWhereUniqueInput;
  data: PictureUpdateDataInput;
}

export interface PaymentAccountCreateInput {
  type?: PAYMENT_PROVIDER;
  user: UserCreateOneWithoutPaymentAccountInput;
  payments?: PaymentCreateManyWithoutPaymentMethodInput;
  paypal?: PaypalInformationCreateOneWithoutPaymentAccountInput;
  creditcard?: CreditCardInformationCreateOneWithoutPaymentAccountInput;
}

export interface PictureUpsertWithWhereUniqueNestedInput {
  where: PictureWhereUniqueInput;
  update: PictureUpdateDataInput;
  create: PictureCreateInput;
}

export interface UserUpsertWithoutNotificationsInput {
  update: UserUpdateWithoutNotificationsDataInput;
  create: UserCreateWithoutNotificationsInput;
}

export interface RestaurantUpsertWithoutLocationInput {
  update: RestaurantUpdateWithoutLocationDataInput;
  create: RestaurantCreateWithoutLocationInput;
}

export interface NotificationUpdateInput {
  type?: NOTIFICATION_TYPE;
  user?: UserUpdateOneRequiredWithoutNotificationsInput;
  link?: String;
  readDate?: DateTimeInput;
}

export interface LocationUpsertWithoutExperienceInput {
  update: LocationUpdateWithoutExperienceDataInput;
  create: LocationCreateWithoutExperienceInput;
}

export type PricingWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ReviewUpdateManyWithoutExperienceInput {
  create?:
    | ReviewCreateWithoutExperienceInput[]
    | ReviewCreateWithoutExperienceInput;
  delete?: ReviewWhereUniqueInput[] | ReviewWhereUniqueInput;
  connect?: ReviewWhereUniqueInput[] | ReviewWhereUniqueInput;
  disconnect?: ReviewWhereUniqueInput[] | ReviewWhereUniqueInput;
  update?:
    | ReviewUpdateWithWhereUniqueWithoutExperienceInput[]
    | ReviewUpdateWithWhereUniqueWithoutExperienceInput;
  upsert?:
    | ReviewUpsertWithWhereUniqueWithoutExperienceInput[]
    | ReviewUpsertWithWhereUniqueWithoutExperienceInput;
}

export interface MessageUpdateInput {
  from?: UserUpdateOneRequiredWithoutSentMessagesInput;
  to?: UserUpdateOneRequiredWithoutReceivedMessagesInput;
  deliveredAt?: DateTimeInput;
  readAt?: DateTimeInput;
}

export interface ReviewUpdateWithWhereUniqueWithoutExperienceInput {
  where: ReviewWhereUniqueInput;
  data: ReviewUpdateWithoutExperienceDataInput;
}

export interface LocationCreateInput {
  lat: Float;
  lng: Float;
  neighbourHood?: NeighbourhoodCreateOneWithoutLocationsInput;
  user?: UserCreateOneWithoutLocationInput;
  place?: PlaceCreateOneWithoutLocationInput;
  address: String;
  directions: String;
  experience?: ExperienceCreateOneWithoutLocationInput;
  restaurant?: RestaurantCreateOneWithoutLocationInput;
}

export interface ReviewUpdateWithoutExperienceDataInput {
  text?: String;
  stars?: Int;
  accuracy?: Int;
  location?: Int;
  checkIn?: Int;
  value?: Int;
  cleanliness?: Int;
  communication?: Int;
  place?: PlaceUpdateOneRequiredWithoutReviewsInput;
}

export interface PlaceUpdateWithoutGuestRequirementsDataInput {
  name?: String;
  size?: PLACE_SIZES;
  shortDescription?: String;
  description?: String;
  slug?: String;
  maxGuests?: Int;
  numBedrooms?: Int;
  numBeds?: Int;
  numBaths?: Int;
  reviews?: ReviewUpdateManyWithoutPlaceInput;
  amenities?: AmenitiesUpdateOneRequiredWithoutPlaceInput;
  host?: UserUpdateOneRequiredWithoutOwnedPlacesInput;
  pricing?: PricingUpdateOneRequiredWithoutPlaceInput;
  location?: LocationUpdateOneRequiredWithoutPlaceInput;
  views?: ViewsUpdateOneRequiredWithoutPlaceInput;
  policies?: PoliciesUpdateOneWithoutPlaceInput;
  houseRules?: HouseRulesUpdateOneInput;
  bookings?: BookingUpdateManyWithoutPlaceInput;
  pictures?: PictureUpdateManyInput;
  popularity?: Int;
}

export interface PlaceUpdateOneRequiredWithoutReviewsInput {
  create?: PlaceCreateWithoutReviewsInput;
  update?: PlaceUpdateWithoutReviewsDataInput;
  upsert?: PlaceUpsertWithoutReviewsInput;
  connect?: PlaceWhereUniqueInput;
}

export interface PlaceCreateWithoutGuestRequirementsInput {
  name: String;
  size?: PLACE_SIZES;
  shortDescription: String;
  description: String;
  slug: String;
  maxGuests: Int;
  numBedrooms: Int;
  numBeds: Int;
  numBaths: Int;
  reviews?: ReviewCreateManyWithoutPlaceInput;
  amenities: AmenitiesCreateOneWithoutPlaceInput;
  host: UserCreateOneWithoutOwnedPlacesInput;
  pricing: PricingCreateOneWithoutPlaceInput;
  location: LocationCreateOneWithoutPlaceInput;
  views: ViewsCreateOneWithoutPlaceInput;
  policies?: PoliciesCreateOneWithoutPlaceInput;
  houseRules?: HouseRulesCreateOneInput;
  bookings?: BookingCreateManyWithoutPlaceInput;
  pictures?: PictureCreateManyInput;
  popularity: Int;
}

export interface PlaceUpdateWithoutReviewsDataInput {
  name?: String;
  size?: PLACE_SIZES;
  shortDescription?: String;
  description?: String;
  slug?: String;
  maxGuests?: Int;
  numBedrooms?: Int;
  numBeds?: Int;
  numBaths?: Int;
  amenities?: AmenitiesUpdateOneRequiredWithoutPlaceInput;
  host?: UserUpdateOneRequiredWithoutOwnedPlacesInput;
  pricing?: PricingUpdateOneRequiredWithoutPlaceInput;
  location?: LocationUpdateOneRequiredWithoutPlaceInput;
  views?: ViewsUpdateOneRequiredWithoutPlaceInput;
  guestRequirements?: GuestRequirementsUpdateOneWithoutPlaceInput;
  policies?: PoliciesUpdateOneWithoutPlaceInput;
  houseRules?: HouseRulesUpdateOneInput;
  bookings?: BookingUpdateManyWithoutPlaceInput;
  pictures?: PictureUpdateManyInput;
  popularity?: Int;
}

export interface ExperienceUpsertWithoutCategoryInput {
  update: ExperienceUpdateWithoutCategoryDataInput;
  create: ExperienceCreateWithoutCategoryInput;
}

export interface PlaceUpsertWithoutReviewsInput {
  update: PlaceUpdateWithoutReviewsDataInput;
  create: PlaceCreateWithoutReviewsInput;
}

export interface ReviewCreateManyWithoutPlaceInput {
  create?: ReviewCreateWithoutPlaceInput[] | ReviewCreateWithoutPlaceInput;
  connect?: ReviewWhereUniqueInput[] | ReviewWhereUniqueInput;
}

export interface ReviewUpsertWithWhereUniqueWithoutExperienceInput {
  where: ReviewWhereUniqueInput;
  update: ReviewUpdateWithoutExperienceDataInput;
  create: ReviewCreateWithoutExperienceInput;
}

export interface ExperienceCategoryCreateOneWithoutExperienceInput {
  create?: ExperienceCategoryCreateWithoutExperienceInput;
  connect?: ExperienceCategoryWhereUniqueInput;
}

export interface PictureUpdateOneRequiredInput {
  create?: PictureCreateInput;
  update?: PictureUpdateDataInput;
  upsert?: PictureUpsertNestedInput;
  connect?: PictureWhereUniqueInput;
}

export interface PlaceCreateManyWithoutHostInput {
  create?: PlaceCreateWithoutHostInput[] | PlaceCreateWithoutHostInput;
  connect?: PlaceWhereUniqueInput[] | PlaceWhereUniqueInput;
}

export interface ExperienceUpsertWithWhereUniqueWithoutHostInput {
  where: ExperienceWhereUniqueInput;
  update: ExperienceUpdateWithoutHostDataInput;
  create: ExperienceCreateWithoutHostInput;
}

export interface PricingCreateOneWithoutPlaceInput {
  create?: PricingCreateWithoutPlaceInput;
  connect?: PricingWhereUniqueInput;
}

export interface UserUpsertWithoutReceivedMessagesInput {
  update: UserUpdateWithoutReceivedMessagesDataInput;
  create: UserCreateWithoutReceivedMessagesInput;
}

export interface NeighbourhoodCreateOneWithoutLocationsInput {
  create?: NeighbourhoodCreateWithoutLocationsInput;
  connect?: NeighbourhoodWhereUniqueInput;
}

export interface MessageUpsertWithWhereUniqueWithoutFromInput {
  where: MessageWhereUniqueInput;
  update: MessageUpdateWithoutFromDataInput;
  create: MessageCreateWithoutFromInput;
}

export interface CityCreateOneWithoutNeighbourhoodsInput {
  create?: CityCreateWithoutNeighbourhoodsInput;
  connect?: CityWhereUniqueInput;
}

export interface MessageUpdateManyWithoutToInput {
  create?: MessageCreateWithoutToInput[] | MessageCreateWithoutToInput;
  delete?: MessageWhereUniqueInput[] | MessageWhereUniqueInput;
  connect?: MessageWhereUniqueInput[] | MessageWhereUniqueInput;
  disconnect?: MessageWhereUniqueInput[] | MessageWhereUniqueInput;
  update?:
    | MessageUpdateWithWhereUniqueWithoutToInput[]
    | MessageUpdateWithWhereUniqueWithoutToInput;
  upsert?:
    | MessageUpsertWithWhereUniqueWithoutToInput[]
    | MessageUpsertWithWhereUniqueWithoutToInput;
}

export interface BookingCreateManyWithoutBookeeInput {
  create?: BookingCreateWithoutBookeeInput[] | BookingCreateWithoutBookeeInput;
  connect?: BookingWhereUniqueInput[] | BookingWhereUniqueInput;
}

export interface MessageUpdateWithWhereUniqueWithoutToInput {
  where: MessageWhereUniqueInput;
  data: MessageUpdateWithoutToDataInput;
}

export interface UserCreateOneWithoutOwnedPlacesInput {
  create?: UserCreateWithoutOwnedPlacesInput;
  connect?: UserWhereUniqueInput;
}

export interface MessageUpdateWithoutToDataInput {
  from?: UserUpdateOneRequiredWithoutSentMessagesInput;
  deliveredAt?: DateTimeInput;
  readAt?: DateTimeInput;
}

export interface PlaceCreateOneWithoutLocationInput {
  create?: PlaceCreateWithoutLocationInput;
  connect?: PlaceWhereUniqueInput;
}

export interface UserUpdateOneRequiredWithoutSentMessagesInput {
  create?: UserCreateWithoutSentMessagesInput;
  update?: UserUpdateWithoutSentMessagesDataInput;
  upsert?: UserUpsertWithoutSentMessagesInput;
  connect?: UserWhereUniqueInput;
}

export interface GuestRequirementsCreateOneWithoutPlaceInput {
  create?: GuestRequirementsCreateWithoutPlaceInput;
  connect?: GuestRequirementsWhereUniqueInput;
}

export interface UserUpdateWithoutSentMessagesDataInput {
  firstName?: String;
  lastName?: String;
  email?: String;
  password?: String;
  phone?: String;
  responseRate?: Float;
  responseTime?: Int;
  isSuperHost?: Boolean;
  ownedPlaces?: PlaceUpdateManyWithoutHostInput;
  location?: LocationUpdateOneWithoutUserInput;
  bookings?: BookingUpdateManyWithoutBookeeInput;
  paymentAccount?: PaymentAccountUpdateManyWithoutUserInput;
  receivedMessages?: MessageUpdateManyWithoutToInput;
  notifications?: NotificationUpdateManyWithoutUserInput;
  profilePicture?: PictureUpdateOneInput;
  hostingExperiences?: ExperienceUpdateManyWithoutHostInput;
}

export interface HouseRulesCreateOneInput {
  create?: HouseRulesCreateInput;
  connect?: HouseRulesWhereUniqueInput;
}

export interface UserUpsertWithoutSentMessagesInput {
  update: UserUpdateWithoutSentMessagesDataInput;
  create: UserCreateWithoutSentMessagesInput;
}

export interface UserCreateOneWithoutBookingsInput {
  create?: UserCreateWithoutBookingsInput;
  connect?: UserWhereUniqueInput;
}

export interface MessageUpsertWithWhereUniqueWithoutToInput {
  where: MessageWhereUniqueInput;
  update: MessageUpdateWithoutToDataInput;
  create: MessageCreateWithoutToInput;
}

export interface PaymentCreateManyWithoutPaymentMethodInput {
  create?:
    | PaymentCreateWithoutPaymentMethodInput[]
    | PaymentCreateWithoutPaymentMethodInput;
  connect?: PaymentWhereUniqueInput[] | PaymentWhereUniqueInput;
}

export interface UserUpsertWithoutBookingsInput {
  update: UserUpdateWithoutBookingsDataInput;
  create: UserCreateWithoutBookingsInput;
}

export interface PaypalInformationCreateOneWithoutPaymentAccountInput {
  create?: PaypalInformationCreateWithoutPaymentAccountInput;
  connect?: PaypalInformationWhereUniqueInput;
}

export interface PaymentUpdateOneWithoutBookingInput {
  create?: PaymentCreateWithoutBookingInput;
  update?: PaymentUpdateWithoutBookingDataInput;
  upsert?: PaymentUpsertWithoutBookingInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: PaymentWhereUniqueInput;
}

export interface MessageCreateManyWithoutFromInput {
  create?: MessageCreateWithoutFromInput[] | MessageCreateWithoutFromInput;
  connect?: MessageWhereUniqueInput[] | MessageWhereUniqueInput;
}

export interface PaymentUpdateWithoutBookingDataInput {
  serviceFee?: Float;
  placePrice?: Float;
  totalPrice?: Float;
  paymentMethod?: PaymentAccountUpdateOneRequiredWithoutPaymentsInput;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserWhereInput;
  AND?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  OR?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  NOT?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
}

export interface PaymentAccountUpdateOneRequiredWithoutPaymentsInput {
  create?: PaymentAccountCreateWithoutPaymentsInput;
  update?: PaymentAccountUpdateWithoutPaymentsDataInput;
  upsert?: PaymentAccountUpsertWithoutPaymentsInput;
  connect?: PaymentAccountWhereUniqueInput;
}

export interface BookingWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  bookee?: UserWhereInput;
  place?: PlaceWhereInput;
  startDate?: DateTimeInput;
  startDate_not?: DateTimeInput;
  startDate_in?: DateTimeInput[] | DateTimeInput;
  startDate_not_in?: DateTimeInput[] | DateTimeInput;
  startDate_lt?: DateTimeInput;
  startDate_lte?: DateTimeInput;
  startDate_gt?: DateTimeInput;
  startDate_gte?: DateTimeInput;
  endDate?: DateTimeInput;
  endDate_not?: DateTimeInput;
  endDate_in?: DateTimeInput[] | DateTimeInput;
  endDate_not_in?: DateTimeInput[] | DateTimeInput;
  endDate_lt?: DateTimeInput;
  endDate_lte?: DateTimeInput;
  endDate_gt?: DateTimeInput;
  endDate_gte?: DateTimeInput;
  payment?: PaymentWhereInput;
  AND?: BookingWhereInput[] | BookingWhereInput;
  OR?: BookingWhereInput[] | BookingWhereInput;
  NOT?: BookingWhereInput[] | BookingWhereInput;
}

export interface PaymentAccountUpdateWithoutPaymentsDataInput {
  type?: PAYMENT_PROVIDER;
  user?: UserUpdateOneRequiredWithoutPaymentAccountInput;
  paypal?: PaypalInformationUpdateOneWithoutPaymentAccountInput;
  creditcard?: CreditCardInformationUpdateOneWithoutPaymentAccountInput;
}

export interface ExperienceWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  category?: ExperienceCategoryWhereInput;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  host?: UserWhereInput;
  location?: LocationWhereInput;
  pricePerPerson?: Int;
  pricePerPerson_not?: Int;
  pricePerPerson_in?: Int[] | Int;
  pricePerPerson_not_in?: Int[] | Int;
  pricePerPerson_lt?: Int;
  pricePerPerson_lte?: Int;
  pricePerPerson_gt?: Int;
  pricePerPerson_gte?: Int;
  reviews_every?: ReviewWhereInput;
  reviews_some?: ReviewWhereInput;
  reviews_none?: ReviewWhereInput;
  preview?: PictureWhereInput;
  popularity?: Int;
  popularity_not?: Int;
  popularity_in?: Int[] | Int;
  popularity_not_in?: Int[] | Int;
  popularity_lt?: Int;
  popularity_lte?: Int;
  popularity_gt?: Int;
  popularity_gte?: Int;
  AND?: ExperienceWhereInput[] | ExperienceWhereInput;
  OR?: ExperienceWhereInput[] | ExperienceWhereInput;
  NOT?: ExperienceWhereInput[] | ExperienceWhereInput;
}

export interface UserUpdateOneRequiredWithoutPaymentAccountInput {
  create?: UserCreateWithoutPaymentAccountInput;
  update?: UserUpdateWithoutPaymentAccountDataInput;
  upsert?: UserUpsertWithoutPaymentAccountInput;
  connect?: UserWhereUniqueInput;
}

export interface GuestRequirementsSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: GuestRequirementsWhereInput;
  AND?:
    | GuestRequirementsSubscriptionWhereInput[]
    | GuestRequirementsSubscriptionWhereInput;
  OR?:
    | GuestRequirementsSubscriptionWhereInput[]
    | GuestRequirementsSubscriptionWhereInput;
  NOT?:
    | GuestRequirementsSubscriptionWhereInput[]
    | GuestRequirementsSubscriptionWhereInput;
}

export interface UserUpdateWithoutPaymentAccountDataInput {
  firstName?: String;
  lastName?: String;
  email?: String;
  password?: String;
  phone?: String;
  responseRate?: Float;
  responseTime?: Int;
  isSuperHost?: Boolean;
  ownedPlaces?: PlaceUpdateManyWithoutHostInput;
  location?: LocationUpdateOneWithoutUserInput;
  bookings?: BookingUpdateManyWithoutBookeeInput;
  sentMessages?: MessageUpdateManyWithoutFromInput;
  receivedMessages?: MessageUpdateManyWithoutToInput;
  notifications?: NotificationUpdateManyWithoutUserInput;
  profilePicture?: PictureUpdateOneInput;
  hostingExperiences?: ExperienceUpdateManyWithoutHostInput;
}

export interface AmenitiesSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: AmenitiesWhereInput;
  AND?: AmenitiesSubscriptionWhereInput[] | AmenitiesSubscriptionWhereInput;
  OR?: AmenitiesSubscriptionWhereInput[] | AmenitiesSubscriptionWhereInput;
  NOT?: AmenitiesSubscriptionWhereInput[] | AmenitiesSubscriptionWhereInput;
}

export interface UserUpsertWithoutPaymentAccountInput {
  update: UserUpdateWithoutPaymentAccountDataInput;
  create: UserCreateWithoutPaymentAccountInput;
}

export type CreditCardInformationWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface PaymentAccountUpsertWithoutPaymentsInput {
  update: PaymentAccountUpdateWithoutPaymentsDataInput;
  create: PaymentAccountCreateWithoutPaymentsInput;
}

export interface LocationUpsertWithoutRestaurantInput {
  update: LocationUpdateWithoutRestaurantDataInput;
  create: LocationCreateWithoutRestaurantInput;
}

export interface PaymentUpsertWithoutBookingInput {
  update: PaymentUpdateWithoutBookingDataInput;
  create: PaymentCreateWithoutBookingInput;
}

export interface LocationCreateOneWithoutRestaurantInput {
  create?: LocationCreateWithoutRestaurantInput;
  connect?: LocationWhereUniqueInput;
}

export interface BookingUpsertWithWhereUniqueWithoutPlaceInput {
  where: BookingWhereUniqueInput;
  update: BookingUpdateWithoutPlaceDataInput;
  create: BookingCreateWithoutPlaceInput;
}

export type LocationWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface PlaceUpsertWithoutLocationInput {
  update: PlaceUpdateWithoutLocationDataInput;
  create: PlaceCreateWithoutLocationInput;
}

export type NeighbourhoodWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ExperienceUpdateOneWithoutLocationInput {
  create?: ExperienceCreateWithoutLocationInput;
  update?: ExperienceUpdateWithoutLocationDataInput;
  upsert?: ExperienceUpsertWithoutLocationInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: ExperienceWhereUniqueInput;
}

export type PaymentWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ExperienceUpdateWithoutLocationDataInput {
  category?: ExperienceCategoryUpdateOneWithoutExperienceInput;
  title?: String;
  host?: UserUpdateOneRequiredWithoutHostingExperiencesInput;
  pricePerPerson?: Int;
  reviews?: ReviewUpdateManyWithoutExperienceInput;
  preview?: PictureUpdateOneRequiredInput;
  popularity?: Int;
}

export type PaypalInformationWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ExperienceUpsertWithoutLocationInput {
  update: ExperienceUpdateWithoutLocationDataInput;
  create: ExperienceCreateWithoutLocationInput;
}

export interface PaymentCreateInput {
  serviceFee: Float;
  placePrice: Float;
  totalPrice: Float;
  booking: BookingCreateOneWithoutPaymentInput;
  paymentMethod: PaymentAccountCreateOneWithoutPaymentsInput;
}

export interface LocationUpsertWithoutUserInput {
  update: LocationUpdateWithoutUserDataInput;
  create: LocationCreateWithoutUserInput;
}

export interface UserCreateOneWithoutNotificationsInput {
  create?: UserCreateWithoutNotificationsInput;
  connect?: UserWhereUniqueInput;
}

export interface UserUpsertWithoutOwnedPlacesInput {
  update: UserUpdateWithoutOwnedPlacesDataInput;
  create: UserCreateWithoutOwnedPlacesInput;
}

export interface MessageCreateInput {
  from: UserCreateOneWithoutSentMessagesInput;
  to: UserCreateOneWithoutReceivedMessagesInput;
  deliveredAt: DateTimeInput;
  readAt: DateTimeInput;
}

export interface PlaceUpsertWithoutBookingsInput {
  update: PlaceUpdateWithoutBookingsDataInput;
  create: PlaceCreateWithoutBookingsInput;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  email?: String;
}>;

export interface BookingUpsertWithWhereUniqueWithoutBookeeInput {
  where: BookingWhereUniqueInput;
  update: BookingUpdateWithoutBookeeDataInput;
  create: BookingCreateWithoutBookeeInput;
}

export interface ExperienceUpdateOneWithoutCategoryInput {
  create?: ExperienceCreateWithoutCategoryInput;
  update?: ExperienceUpdateWithoutCategoryDataInput;
  upsert?: ExperienceUpsertWithoutCategoryInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: ExperienceWhereUniqueInput;
}

export interface UserUpsertWithoutLocationInput {
  update: UserUpdateWithoutLocationDataInput;
  create: UserCreateWithoutLocationInput;
}

export interface ExperienceCreateOneWithoutReviewsInput {
  create?: ExperienceCreateWithoutReviewsInput;
  connect?: ExperienceWhereUniqueInput;
}

export interface LocationUpsertWithoutPlaceInput {
  update: LocationUpdateWithoutPlaceDataInput;
  create: LocationCreateWithoutPlaceInput;
}

export interface AmenitiesCreateOneWithoutPlaceInput {
  create?: AmenitiesCreateWithoutPlaceInput;
  connect?: AmenitiesWhereUniqueInput;
}

export interface PlaceUpsertWithWhereUniqueWithoutHostInput {
  where: PlaceWhereUniqueInput;
  update: PlaceUpdateWithoutHostDataInput;
  create: PlaceCreateWithoutHostInput;
}

export interface PictureCreateOneInput {
  create?: PictureCreateInput;
  connect?: PictureWhereUniqueInput;
}

export interface UserUpsertWithoutHostingExperiencesInput {
  update: UserUpdateWithoutHostingExperiencesDataInput;
  create: UserCreateWithoutHostingExperiencesInput;
}

export interface PlaceCreateOneWithoutBookingsInput {
  create?: PlaceCreateWithoutBookingsInput;
  connect?: PlaceWhereUniqueInput;
}

export interface ExperienceUpsertWithoutReviewsInput {
  update: ExperienceUpdateWithoutReviewsDataInput;
  create: ExperienceCreateWithoutReviewsInput;
}

export interface ViewsCreateOneWithoutPlaceInput {
  create?: ViewsCreateWithoutPlaceInput;
  connect?: ViewsWhereUniqueInput;
}

export interface ReviewUpsertWithWhereUniqueWithoutPlaceInput {
  where: ReviewWhereUniqueInput;
  update: ReviewUpdateWithoutPlaceDataInput;
  create: ReviewCreateWithoutPlaceInput;
}

export interface BookingCreateManyWithoutPlaceInput {
  create?: BookingCreateWithoutPlaceInput[] | BookingCreateWithoutPlaceInput;
  connect?: BookingWhereUniqueInput[] | BookingWhereUniqueInput;
}

export interface PlaceUpsertWithoutAmenitiesInput {
  update: PlaceUpdateWithoutAmenitiesDataInput;
  create: PlaceCreateWithoutAmenitiesInput;
}

export interface BookingCreateOneWithoutPaymentInput {
  create?: BookingCreateWithoutPaymentInput;
  connect?: BookingWhereUniqueInput;
}

export interface ExperienceUpdateInput {
  category?: ExperienceCategoryUpdateOneWithoutExperienceInput;
  title?: String;
  host?: UserUpdateOneRequiredWithoutHostingExperiencesInput;
  location?: LocationUpdateOneRequiredWithoutExperienceInput;
  pricePerPerson?: Int;
  reviews?: ReviewUpdateManyWithoutExperienceInput;
  preview?: PictureUpdateOneRequiredInput;
  popularity?: Int;
}

export interface UserCreateOneWithoutReceivedMessagesInput {
  create?: UserCreateWithoutReceivedMessagesInput;
  connect?: UserWhereUniqueInput;
}

export interface ExperienceCreateInput {
  category?: ExperienceCategoryCreateOneWithoutExperienceInput;
  title: String;
  host: UserCreateOneWithoutHostingExperiencesInput;
  location: LocationCreateOneWithoutExperienceInput;
  pricePerPerson: Int;
  reviews?: ReviewCreateManyWithoutExperienceInput;
  preview: PictureCreateOneInput;
  popularity: Int;
}

export interface RestaurantWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  avgPricePerPerson?: Int;
  avgPricePerPerson_not?: Int;
  avgPricePerPerson_in?: Int[] | Int;
  avgPricePerPerson_not_in?: Int[] | Int;
  avgPricePerPerson_lt?: Int;
  avgPricePerPerson_lte?: Int;
  avgPricePerPerson_gt?: Int;
  avgPricePerPerson_gte?: Int;
  pictures_every?: PictureWhereInput;
  pictures_some?: PictureWhereInput;
  pictures_none?: PictureWhereInput;
  location?: LocationWhereInput;
  isCurated?: Boolean;
  isCurated_not?: Boolean;
  slug?: String;
  slug_not?: String;
  slug_in?: String[] | String;
  slug_not_in?: String[] | String;
  slug_lt?: String;
  slug_lte?: String;
  slug_gt?: String;
  slug_gte?: String;
  slug_contains?: String;
  slug_not_contains?: String;
  slug_starts_with?: String;
  slug_not_starts_with?: String;
  slug_ends_with?: String;
  slug_not_ends_with?: String;
  popularity?: Int;
  popularity_not?: Int;
  popularity_in?: Int[] | Int;
  popularity_not_in?: Int[] | Int;
  popularity_lt?: Int;
  popularity_lte?: Int;
  popularity_gt?: Int;
  popularity_gte?: Int;
  AND?: RestaurantWhereInput[] | RestaurantWhereInput;
  OR?: RestaurantWhereInput[] | RestaurantWhereInput;
  NOT?: RestaurantWhereInput[] | RestaurantWhereInput;
}

export interface BookingCreateInput {
  bookee: UserCreateOneWithoutBookingsInput;
  place: PlaceCreateOneWithoutBookingsInput;
  startDate: DateTimeInput;
  endDate: DateTimeInput;
  payment?: PaymentCreateOneWithoutBookingInput;
}

export interface CreditCardInformationSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CreditCardInformationWhereInput;
  AND?:
    | CreditCardInformationSubscriptionWhereInput[]
    | CreditCardInformationSubscriptionWhereInput;
  OR?:
    | CreditCardInformationSubscriptionWhereInput[]
    | CreditCardInformationSubscriptionWhereInput;
  NOT?:
    | CreditCardInformationSubscriptionWhereInput[]
    | CreditCardInformationSubscriptionWhereInput;
}

export interface BookingUpdateInput {
  bookee?: UserUpdateOneRequiredWithoutBookingsInput;
  place?: PlaceUpdateOneRequiredWithoutBookingsInput;
  startDate?: DateTimeInput;
  endDate?: DateTimeInput;
  payment?: PaymentUpdateOneWithoutBookingInput;
}

export interface UserCreateInput {
  firstName: String;
  lastName: String;
  email: String;
  password: String;
  phone: String;
  responseRate?: Float;
  responseTime?: Int;
  isSuperHost?: Boolean;
  ownedPlaces?: PlaceCreateManyWithoutHostInput;
  location?: LocationCreateOneWithoutUserInput;
  bookings?: BookingCreateManyWithoutBookeeInput;
  paymentAccount?: PaymentAccountCreateManyWithoutUserInput;
  sentMessages?: MessageCreateManyWithoutFromInput;
  receivedMessages?: MessageCreateManyWithoutToInput;
  notifications?: NotificationCreateManyWithoutUserInput;
  profilePicture?: PictureCreateOneInput;
  hostingExperiences?: ExperienceCreateManyWithoutHostInput;
}

export interface CityCreateInput {
  name: String;
  neighbourhoods?: NeighbourhoodCreateManyWithoutCityInput;
}

export interface AmenitiesWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  place?: PlaceWhereInput;
  elevator?: Boolean;
  elevator_not?: Boolean;
  petsAllowed?: Boolean;
  petsAllowed_not?: Boolean;
  internet?: Boolean;
  internet_not?: Boolean;
  kitchen?: Boolean;
  kitchen_not?: Boolean;
  wirelessInternet?: Boolean;
  wirelessInternet_not?: Boolean;
  familyKidFriendly?: Boolean;
  familyKidFriendly_not?: Boolean;
  freeParkingOnPremises?: Boolean;
  freeParkingOnPremises_not?: Boolean;
  hotTub?: Boolean;
  hotTub_not?: Boolean;
  pool?: Boolean;
  pool_not?: Boolean;
  smokingAllowed?: Boolean;
  smokingAllowed_not?: Boolean;
  wheelchairAccessible?: Boolean;
  wheelchairAccessible_not?: Boolean;
  breakfast?: Boolean;
  breakfast_not?: Boolean;
  cableTv?: Boolean;
  cableTv_not?: Boolean;
  suitableForEvents?: Boolean;
  suitableForEvents_not?: Boolean;
  dryer?: Boolean;
  dryer_not?: Boolean;
  washer?: Boolean;
  washer_not?: Boolean;
  indoorFireplace?: Boolean;
  indoorFireplace_not?: Boolean;
  tv?: Boolean;
  tv_not?: Boolean;
  heating?: Boolean;
  heating_not?: Boolean;
  hangers?: Boolean;
  hangers_not?: Boolean;
  iron?: Boolean;
  iron_not?: Boolean;
  hairDryer?: Boolean;
  hairDryer_not?: Boolean;
  doorman?: Boolean;
  doorman_not?: Boolean;
  paidParkingOffPremises?: Boolean;
  paidParkingOffPremises_not?: Boolean;
  freeParkingOnStreet?: Boolean;
  freeParkingOnStreet_not?: Boolean;
  gym?: Boolean;
  gym_not?: Boolean;
  airConditioning?: Boolean;
  airConditioning_not?: Boolean;
  shampoo?: Boolean;
  shampoo_not?: Boolean;
  essentials?: Boolean;
  essentials_not?: Boolean;
  laptopFriendlyWorkspace?: Boolean;
  laptopFriendlyWorkspace_not?: Boolean;
  privateEntrance?: Boolean;
  privateEntrance_not?: Boolean;
  buzzerWirelessIntercom?: Boolean;
  buzzerWirelessIntercom_not?: Boolean;
  babyBath?: Boolean;
  babyBath_not?: Boolean;
  babyMonitor?: Boolean;
  babyMonitor_not?: Boolean;
  babysitterRecommendations?: Boolean;
  babysitterRecommendations_not?: Boolean;
  bathtub?: Boolean;
  bathtub_not?: Boolean;
  changingTable?: Boolean;
  changingTable_not?: Boolean;
  childrensBooksAndToys?: Boolean;
  childrensBooksAndToys_not?: Boolean;
  childrensDinnerware?: Boolean;
  childrensDinnerware_not?: Boolean;
  crib?: Boolean;
  crib_not?: Boolean;
  AND?: AmenitiesWhereInput[] | AmenitiesWhereInput;
  OR?: AmenitiesWhereInput[] | AmenitiesWhereInput;
  NOT?: AmenitiesWhereInput[] | AmenitiesWhereInput;
}

export interface NeighbourhoodCreateManyWithoutCityInput {
  create?:
    | NeighbourhoodCreateWithoutCityInput[]
    | NeighbourhoodCreateWithoutCityInput;
  connect?: NeighbourhoodWhereUniqueInput[] | NeighbourhoodWhereUniqueInput;
}

export type NotificationWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface NeighbourhoodCreateWithoutCityInput {
  locations?: LocationCreateManyWithoutNeighbourHoodInput;
  name: String;
  slug: String;
  homePreview?: PictureCreateOneInput;
  featured: Boolean;
  popularity: Int;
}

export interface PaymentAccountUpdateInput {
  type?: PAYMENT_PROVIDER;
  user?: UserUpdateOneRequiredWithoutPaymentAccountInput;
  payments?: PaymentUpdateManyWithoutPaymentMethodInput;
  paypal?: PaypalInformationUpdateOneWithoutPaymentAccountInput;
  creditcard?: CreditCardInformationUpdateOneWithoutPaymentAccountInput;
}

export interface LocationCreateManyWithoutNeighbourHoodInput {
  create?:
    | LocationCreateWithoutNeighbourHoodInput[]
    | LocationCreateWithoutNeighbourHoodInput;
  connect?: LocationWhereUniqueInput[] | LocationWhereUniqueInput;
}

export interface NeighbourhoodUpdateInput {
  locations?: LocationUpdateManyWithoutNeighbourHoodInput;
  name?: String;
  slug?: String;
  homePreview?: PictureUpdateOneInput;
  city?: CityUpdateOneRequiredWithoutNeighbourhoodsInput;
  featured?: Boolean;
  popularity?: Int;
}

export interface LocationCreateWithoutNeighbourHoodInput {
  lat: Float;
  lng: Float;
  user?: UserCreateOneWithoutLocationInput;
  place?: PlaceCreateOneWithoutLocationInput;
  address: String;
  directions: String;
  experience?: ExperienceCreateOneWithoutLocationInput;
  restaurant?: RestaurantCreateOneWithoutLocationInput;
}

export interface GuestRequirementsCreateInput {
  govIssuedId?: Boolean;
  recommendationsFromOtherHosts?: Boolean;
  guestTripInformation?: Boolean;
  place: PlaceCreateOneWithoutGuestRequirementsInput;
}

export interface CityUpdateInput {
  name?: String;
  neighbourhoods?: NeighbourhoodUpdateManyWithoutCityInput;
}

export interface UserCreateOneWithoutHostingExperiencesInput {
  create?: UserCreateWithoutHostingExperiencesInput;
  connect?: UserWhereUniqueInput;
}

export interface NeighbourhoodUpdateManyWithoutCityInput {
  create?:
    | NeighbourhoodCreateWithoutCityInput[]
    | NeighbourhoodCreateWithoutCityInput;
  delete?: NeighbourhoodWhereUniqueInput[] | NeighbourhoodWhereUniqueInput;
  connect?: NeighbourhoodWhereUniqueInput[] | NeighbourhoodWhereUniqueInput;
  disconnect?: NeighbourhoodWhereUniqueInput[] | NeighbourhoodWhereUniqueInput;
  update?:
    | NeighbourhoodUpdateWithWhereUniqueWithoutCityInput[]
    | NeighbourhoodUpdateWithWhereUniqueWithoutCityInput;
  upsert?:
    | NeighbourhoodUpsertWithWhereUniqueWithoutCityInput[]
    | NeighbourhoodUpsertWithWhereUniqueWithoutCityInput;
}

export interface UserCreateOneWithoutLocationInput {
  create?: UserCreateWithoutLocationInput;
  connect?: UserWhereUniqueInput;
}

export interface NeighbourhoodUpdateWithWhereUniqueWithoutCityInput {
  where: NeighbourhoodWhereUniqueInput;
  data: NeighbourhoodUpdateWithoutCityDataInput;
}

export interface PoliciesCreateOneWithoutPlaceInput {
  create?: PoliciesCreateWithoutPlaceInput;
  connect?: PoliciesWhereUniqueInput;
}

export interface NeighbourhoodUpdateWithoutCityDataInput {
  locations?: LocationUpdateManyWithoutNeighbourHoodInput;
  name?: String;
  slug?: String;
  homePreview?: PictureUpdateOneInput;
  featured?: Boolean;
  popularity?: Int;
}

export interface CreditCardInformationCreateOneWithoutPaymentAccountInput {
  create?: CreditCardInformationCreateWithoutPaymentAccountInput;
  connect?: CreditCardInformationWhereUniqueInput;
}

export interface LocationUpdateManyWithoutNeighbourHoodInput {
  create?:
    | LocationCreateWithoutNeighbourHoodInput[]
    | LocationCreateWithoutNeighbourHoodInput;
  delete?: LocationWhereUniqueInput[] | LocationWhereUniqueInput;
  connect?: LocationWhereUniqueInput[] | LocationWhereUniqueInput;
  disconnect?: LocationWhereUniqueInput[] | LocationWhereUniqueInput;
  update?:
    | LocationUpdateWithWhereUniqueWithoutNeighbourHoodInput[]
    | LocationUpdateWithWhereUniqueWithoutNeighbourHoodInput;
  upsert?:
    | LocationUpsertWithWhereUniqueWithoutNeighbourHoodInput[]
    | LocationUpsertWithWhereUniqueWithoutNeighbourHoodInput;
}

export interface PictureWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  url?: String;
  url_not?: String;
  url_in?: String[] | String;
  url_not_in?: String[] | String;
  url_lt?: String;
  url_lte?: String;
  url_gt?: String;
  url_gte?: String;
  url_contains?: String;
  url_not_contains?: String;
  url_starts_with?: String;
  url_not_starts_with?: String;
  url_ends_with?: String;
  url_not_ends_with?: String;
  AND?: PictureWhereInput[] | PictureWhereInput;
  OR?: PictureWhereInput[] | PictureWhereInput;
  NOT?: PictureWhereInput[] | PictureWhereInput;
}

export interface LocationUpdateWithWhereUniqueWithoutNeighbourHoodInput {
  where: LocationWhereUniqueInput;
  data: LocationUpdateWithoutNeighbourHoodDataInput;
}

export interface LocationUpdateOneRequiredWithoutRestaurantInput {
  create?: LocationCreateWithoutRestaurantInput;
  update?: LocationUpdateWithoutRestaurantDataInput;
  upsert?: LocationUpsertWithoutRestaurantInput;
  connect?: LocationWhereUniqueInput;
}

export interface LocationUpdateWithoutNeighbourHoodDataInput {
  lat?: Float;
  lng?: Float;
  user?: UserUpdateOneWithoutLocationInput;
  place?: PlaceUpdateOneWithoutLocationInput;
  address?: String;
  directions?: String;
  experience?: ExperienceUpdateOneWithoutLocationInput;
  restaurant?: RestaurantUpdateOneWithoutLocationInput;
}

export type PaymentAccountWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface LocationUpsertWithWhereUniqueWithoutNeighbourHoodInput {
  where: LocationWhereUniqueInput;
  update: LocationUpdateWithoutNeighbourHoodDataInput;
  create: LocationCreateWithoutNeighbourHoodInput;
}

export type ReviewWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface NeighbourhoodUpsertWithWhereUniqueWithoutCityInput {
  where: NeighbourhoodWhereUniqueInput;
  update: NeighbourhoodUpdateWithoutCityDataInput;
  create: NeighbourhoodCreateWithoutCityInput;
}

export interface LocationCreateOneWithoutPlaceInput {
  create?: LocationCreateWithoutPlaceInput;
  connect?: LocationWhereUniqueInput;
}

export interface CreditCardInformationCreateInput {
  cardNumber: String;
  expiresOnMonth: Int;
  expiresOnYear: Int;
  securityCode: String;
  firstName: String;
  lastName: String;
  postalCode: String;
  country: String;
  paymentAccount?: PaymentAccountCreateOneWithoutCreditcardInput;
}

export interface PaymentAccountCreateManyWithoutUserInput {
  create?:
    | PaymentAccountCreateWithoutUserInput[]
    | PaymentAccountCreateWithoutUserInput;
  connect?: PaymentAccountWhereUniqueInput[] | PaymentAccountWhereUniqueInput;
}

export interface PaymentAccountCreateOneWithoutCreditcardInput {
  create?: PaymentAccountCreateWithoutCreditcardInput;
  connect?: PaymentAccountWhereUniqueInput;
}

export interface LocationWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  lat?: Float;
  lat_not?: Float;
  lat_in?: Float[] | Float;
  lat_not_in?: Float[] | Float;
  lat_lt?: Float;
  lat_lte?: Float;
  lat_gt?: Float;
  lat_gte?: Float;
  lng?: Float;
  lng_not?: Float;
  lng_in?: Float[] | Float;
  lng_not_in?: Float[] | Float;
  lng_lt?: Float;
  lng_lte?: Float;
  lng_gt?: Float;
  lng_gte?: Float;
  neighbourHood?: NeighbourhoodWhereInput;
  user?: UserWhereInput;
  place?: PlaceWhereInput;
  address?: String;
  address_not?: String;
  address_in?: String[] | String;
  address_not_in?: String[] | String;
  address_lt?: String;
  address_lte?: String;
  address_gt?: String;
  address_gte?: String;
  address_contains?: String;
  address_not_contains?: String;
  address_starts_with?: String;
  address_not_starts_with?: String;
  address_ends_with?: String;
  address_not_ends_with?: String;
  directions?: String;
  directions_not?: String;
  directions_in?: String[] | String;
  directions_not_in?: String[] | String;
  directions_lt?: String;
  directions_lte?: String;
  directions_gt?: String;
  directions_gte?: String;
  directions_contains?: String;
  directions_not_contains?: String;
  directions_starts_with?: String;
  directions_not_starts_with?: String;
  directions_ends_with?: String;
  directions_not_ends_with?: String;
  experience?: ExperienceWhereInput;
  restaurant?: RestaurantWhereInput;
  AND?: LocationWhereInput[] | LocationWhereInput;
  OR?: LocationWhereInput[] | LocationWhereInput;
  NOT?: LocationWhereInput[] | LocationWhereInput;
}

export interface PaymentAccountUpdateWithoutCreditcardDataInput {
  type?: PAYMENT_PROVIDER;
  user?: UserUpdateOneRequiredWithoutPaymentAccountInput;
  payments?: PaymentUpdateManyWithoutPaymentMethodInput;
  paypal?: PaypalInformationUpdateOneWithoutPaymentAccountInput;
}

export interface PaymentAccountUpdateOneWithoutCreditcardInput {
  create?: PaymentAccountCreateWithoutCreditcardInput;
  update?: PaymentAccountUpdateWithoutCreditcardDataInput;
  upsert?: PaymentAccountUpsertWithoutCreditcardInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: PaymentAccountWhereUniqueInput;
}

export interface CreditCardInformationUpdateInput {
  cardNumber?: String;
  expiresOnMonth?: Int;
  expiresOnYear?: Int;
  securityCode?: String;
  firstName?: String;
  lastName?: String;
  postalCode?: String;
  country?: String;
  paymentAccount?: PaymentAccountUpdateOneWithoutCreditcardInput;
}

export interface PaymentAccountCreateWithoutCreditcardInput {
  type?: PAYMENT_PROVIDER;
  user: UserCreateOneWithoutPaymentAccountInput;
  payments?: PaymentCreateManyWithoutPaymentMethodInput;
  paypal?: PaypalInformationCreateOneWithoutPaymentAccountInput;
}

export type MessageWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface PricingSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PricingWhereInput;
  AND?: PricingSubscriptionWhereInput[] | PricingSubscriptionWhereInput;
  OR?: PricingSubscriptionWhereInput[] | PricingSubscriptionWhereInput;
  NOT?: PricingSubscriptionWhereInput[] | PricingSubscriptionWhereInput;
}

export interface LocationCreateOneWithoutUserInput {
  create?: LocationCreateWithoutUserInput;
  connect?: LocationWhereUniqueInput;
}

export interface PlaceCreateOneWithoutAmenitiesInput {
  create?: PlaceCreateWithoutAmenitiesInput;
  connect?: PlaceWhereUniqueInput;
}

export interface UserUpdateOneRequiredWithoutNotificationsInput {
  create?: UserCreateWithoutNotificationsInput;
  update?: UserUpdateWithoutNotificationsDataInput;
  upsert?: UserUpsertWithoutNotificationsInput;
  connect?: UserWhereUniqueInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface ViewsPreviousValuesNode {
  id: ID_Output;
  lastWeek: Int;
}

export interface ViewsPreviousValues
  extends Promise<ViewsPreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  lastWeek: () => Promise<Int>;
}

export interface ViewsPreviousValuesSubscription
  extends Promise<AsyncIterator<ViewsPreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  lastWeek: () => Promise<AsyncIterator<Int>>;
}

export interface CityConnectionNode {}

export interface CityConnection
  extends Promise<CityConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<CityEdgeNode>>() => T;
  aggregate: <T = AggregateCity>() => T;
}

export interface CityConnectionSubscription
  extends Promise<AsyncIterator<CityConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CityEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCitySubscription>() => T;
}

export interface ExperienceNode {
  id: ID_Output;
  title: String;
  pricePerPerson: Int;
  popularity: Int;
}

export interface Experience extends Promise<ExperienceNode>, Fragmentable {
  id: () => Promise<ID_Output>;
  category: <T = ExperienceCategory>() => T;
  title: () => Promise<String>;
  host: <T = User>() => T;
  location: <T = Location>() => T;
  pricePerPerson: () => Promise<Int>;
  reviews: <T = FragmentableArray<ReviewNode>>(
    args?: {
      where?: ReviewWhereInput;
      orderBy?: ReviewOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  preview: <T = Picture>() => T;
  popularity: () => Promise<Int>;
}

export interface ExperienceSubscription
  extends Promise<AsyncIterator<ExperienceNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  category: <T = ExperienceCategorySubscription>() => T;
  title: () => Promise<AsyncIterator<String>>;
  host: <T = UserSubscription>() => T;
  location: <T = LocationSubscription>() => T;
  pricePerPerson: () => Promise<AsyncIterator<Int>>;
  reviews: <T = Promise<AsyncIterator<ReviewSubscription>>>(
    args?: {
      where?: ReviewWhereInput;
      orderBy?: ReviewOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  preview: <T = PictureSubscription>() => T;
  popularity: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateBookingNode {
  count: Int;
}

export interface AggregateBooking
  extends Promise<AggregateBookingNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBookingSubscription
  extends Promise<AsyncIterator<AggregateBookingNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ExperienceCategoryNode {
  id: ID_Output;
  mainColor: String;
  name: String;
}

export interface ExperienceCategory
  extends Promise<ExperienceCategoryNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  mainColor: () => Promise<String>;
  name: () => Promise<String>;
  experience: <T = Experience>() => T;
}

export interface ExperienceCategorySubscription
  extends Promise<AsyncIterator<ExperienceCategoryNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  mainColor: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  experience: <T = ExperienceSubscription>() => T;
}

export interface CityEdgeNode {
  cursor: String;
}

export interface CityEdge extends Promise<CityEdgeNode>, Fragmentable {
  node: <T = City>() => T;
  cursor: () => Promise<String>;
}

export interface CityEdgeSubscription
  extends Promise<AsyncIterator<CityEdgeNode>>,
    Fragmentable {
  node: <T = CitySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ReviewPreviousValuesNode {
  id: ID_Output;
  createdAt: DateTimeOutput;
  text: String;
  stars: Int;
  accuracy: Int;
  location: Int;
  checkIn: Int;
  value: Int;
  cleanliness: Int;
  communication: Int;
}

export interface ReviewPreviousValues
  extends Promise<ReviewPreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  text: () => Promise<String>;
  stars: () => Promise<Int>;
  accuracy: () => Promise<Int>;
  location: () => Promise<Int>;
  checkIn: () => Promise<Int>;
  value: () => Promise<Int>;
  cleanliness: () => Promise<Int>;
  communication: () => Promise<Int>;
}

export interface ReviewPreviousValuesSubscription
  extends Promise<AsyncIterator<ReviewPreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  text: () => Promise<AsyncIterator<String>>;
  stars: () => Promise<AsyncIterator<Int>>;
  accuracy: () => Promise<AsyncIterator<Int>>;
  location: () => Promise<AsyncIterator<Int>>;
  checkIn: () => Promise<AsyncIterator<Int>>;
  value: () => Promise<AsyncIterator<Int>>;
  cleanliness: () => Promise<AsyncIterator<Int>>;
  communication: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayloadNode {
  count: Long;
}

export interface BatchPayload extends Promise<BatchPayloadNode>, Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayloadNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface BookingEdgeNode {
  cursor: String;
}

export interface BookingEdge extends Promise<BookingEdgeNode>, Fragmentable {
  node: <T = Booking>() => T;
  cursor: () => Promise<String>;
}

export interface BookingEdgeSubscription
  extends Promise<AsyncIterator<BookingEdgeNode>>,
    Fragmentable {
  node: <T = BookingSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ReviewNode {
  id: ID_Output;
  createdAt: DateTimeOutput;
  text: String;
  stars: Int;
  accuracy: Int;
  location: Int;
  checkIn: Int;
  value: Int;
  cleanliness: Int;
  communication: Int;
}

export interface Review extends Promise<ReviewNode>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  text: () => Promise<String>;
  stars: () => Promise<Int>;
  accuracy: () => Promise<Int>;
  location: () => Promise<Int>;
  checkIn: () => Promise<Int>;
  value: () => Promise<Int>;
  cleanliness: () => Promise<Int>;
  communication: () => Promise<Int>;
  place: <T = Place>() => T;
  experience: <T = Experience>() => T;
}

export interface ReviewSubscription
  extends Promise<AsyncIterator<ReviewNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  text: () => Promise<AsyncIterator<String>>;
  stars: () => Promise<AsyncIterator<Int>>;
  accuracy: () => Promise<AsyncIterator<Int>>;
  location: () => Promise<AsyncIterator<Int>>;
  checkIn: () => Promise<AsyncIterator<Int>>;
  value: () => Promise<AsyncIterator<Int>>;
  cleanliness: () => Promise<AsyncIterator<Int>>;
  communication: () => Promise<AsyncIterator<Int>>;
  place: <T = PlaceSubscription>() => T;
  experience: <T = ExperienceSubscription>() => T;
}

export interface ViewsConnectionNode {}

export interface ViewsConnection
  extends Promise<ViewsConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<ViewsEdgeNode>>() => T;
  aggregate: <T = AggregateViews>() => T;
}

export interface ViewsConnectionSubscription
  extends Promise<AsyncIterator<ViewsConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ViewsEdgeSubscription>>>() => T;
  aggregate: <T = AggregateViewsSubscription>() => T;
}

export interface AggregateViewsNode {
  count: Int;
}

export interface AggregateViews
  extends Promise<AggregateViewsNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateViewsSubscription
  extends Promise<AsyncIterator<AggregateViewsNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateUserNode {
  count: Int;
}

export interface AggregateUser
  extends Promise<AggregateUserNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUserNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BookingConnectionNode {}

export interface BookingConnection
  extends Promise<BookingConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<BookingEdgeNode>>() => T;
  aggregate: <T = AggregateBooking>() => T;
}

export interface BookingConnectionSubscription
  extends Promise<AsyncIterator<BookingConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BookingEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBookingSubscription>() => T;
}

export interface UserConnectionNode {}

export interface UserConnection
  extends Promise<UserConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<UserEdgeNode>>() => T;
  aggregate: <T = AggregateUser>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface AmenitiesNode {
  id: ID_Output;
  elevator: Boolean;
  petsAllowed: Boolean;
  internet: Boolean;
  kitchen: Boolean;
  wirelessInternet: Boolean;
  familyKidFriendly: Boolean;
  freeParkingOnPremises: Boolean;
  hotTub: Boolean;
  pool: Boolean;
  smokingAllowed: Boolean;
  wheelchairAccessible: Boolean;
  breakfast: Boolean;
  cableTv: Boolean;
  suitableForEvents: Boolean;
  dryer: Boolean;
  washer: Boolean;
  indoorFireplace: Boolean;
  tv: Boolean;
  heating: Boolean;
  hangers: Boolean;
  iron: Boolean;
  hairDryer: Boolean;
  doorman: Boolean;
  paidParkingOffPremises: Boolean;
  freeParkingOnStreet: Boolean;
  gym: Boolean;
  airConditioning: Boolean;
  shampoo: Boolean;
  essentials: Boolean;
  laptopFriendlyWorkspace: Boolean;
  privateEntrance: Boolean;
  buzzerWirelessIntercom: Boolean;
  babyBath: Boolean;
  babyMonitor: Boolean;
  babysitterRecommendations: Boolean;
  bathtub: Boolean;
  changingTable: Boolean;
  childrensBooksAndToys: Boolean;
  childrensDinnerware: Boolean;
  crib: Boolean;
}

export interface Amenities extends Promise<AmenitiesNode>, Fragmentable {
  id: () => Promise<ID_Output>;
  place: <T = Place>() => T;
  elevator: () => Promise<Boolean>;
  petsAllowed: () => Promise<Boolean>;
  internet: () => Promise<Boolean>;
  kitchen: () => Promise<Boolean>;
  wirelessInternet: () => Promise<Boolean>;
  familyKidFriendly: () => Promise<Boolean>;
  freeParkingOnPremises: () => Promise<Boolean>;
  hotTub: () => Promise<Boolean>;
  pool: () => Promise<Boolean>;
  smokingAllowed: () => Promise<Boolean>;
  wheelchairAccessible: () => Promise<Boolean>;
  breakfast: () => Promise<Boolean>;
  cableTv: () => Promise<Boolean>;
  suitableForEvents: () => Promise<Boolean>;
  dryer: () => Promise<Boolean>;
  washer: () => Promise<Boolean>;
  indoorFireplace: () => Promise<Boolean>;
  tv: () => Promise<Boolean>;
  heating: () => Promise<Boolean>;
  hangers: () => Promise<Boolean>;
  iron: () => Promise<Boolean>;
  hairDryer: () => Promise<Boolean>;
  doorman: () => Promise<Boolean>;
  paidParkingOffPremises: () => Promise<Boolean>;
  freeParkingOnStreet: () => Promise<Boolean>;
  gym: () => Promise<Boolean>;
  airConditioning: () => Promise<Boolean>;
  shampoo: () => Promise<Boolean>;
  essentials: () => Promise<Boolean>;
  laptopFriendlyWorkspace: () => Promise<Boolean>;
  privateEntrance: () => Promise<Boolean>;
  buzzerWirelessIntercom: () => Promise<Boolean>;
  babyBath: () => Promise<Boolean>;
  babyMonitor: () => Promise<Boolean>;
  babysitterRecommendations: () => Promise<Boolean>;
  bathtub: () => Promise<Boolean>;
  changingTable: () => Promise<Boolean>;
  childrensBooksAndToys: () => Promise<Boolean>;
  childrensDinnerware: () => Promise<Boolean>;
  crib: () => Promise<Boolean>;
}

export interface AmenitiesSubscription
  extends Promise<AsyncIterator<AmenitiesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  place: <T = PlaceSubscription>() => T;
  elevator: () => Promise<AsyncIterator<Boolean>>;
  petsAllowed: () => Promise<AsyncIterator<Boolean>>;
  internet: () => Promise<AsyncIterator<Boolean>>;
  kitchen: () => Promise<AsyncIterator<Boolean>>;
  wirelessInternet: () => Promise<AsyncIterator<Boolean>>;
  familyKidFriendly: () => Promise<AsyncIterator<Boolean>>;
  freeParkingOnPremises: () => Promise<AsyncIterator<Boolean>>;
  hotTub: () => Promise<AsyncIterator<Boolean>>;
  pool: () => Promise<AsyncIterator<Boolean>>;
  smokingAllowed: () => Promise<AsyncIterator<Boolean>>;
  wheelchairAccessible: () => Promise<AsyncIterator<Boolean>>;
  breakfast: () => Promise<AsyncIterator<Boolean>>;
  cableTv: () => Promise<AsyncIterator<Boolean>>;
  suitableForEvents: () => Promise<AsyncIterator<Boolean>>;
  dryer: () => Promise<AsyncIterator<Boolean>>;
  washer: () => Promise<AsyncIterator<Boolean>>;
  indoorFireplace: () => Promise<AsyncIterator<Boolean>>;
  tv: () => Promise<AsyncIterator<Boolean>>;
  heating: () => Promise<AsyncIterator<Boolean>>;
  hangers: () => Promise<AsyncIterator<Boolean>>;
  iron: () => Promise<AsyncIterator<Boolean>>;
  hairDryer: () => Promise<AsyncIterator<Boolean>>;
  doorman: () => Promise<AsyncIterator<Boolean>>;
  paidParkingOffPremises: () => Promise<AsyncIterator<Boolean>>;
  freeParkingOnStreet: () => Promise<AsyncIterator<Boolean>>;
  gym: () => Promise<AsyncIterator<Boolean>>;
  airConditioning: () => Promise<AsyncIterator<Boolean>>;
  shampoo: () => Promise<AsyncIterator<Boolean>>;
  essentials: () => Promise<AsyncIterator<Boolean>>;
  laptopFriendlyWorkspace: () => Promise<AsyncIterator<Boolean>>;
  privateEntrance: () => Promise<AsyncIterator<Boolean>>;
  buzzerWirelessIntercom: () => Promise<AsyncIterator<Boolean>>;
  babyBath: () => Promise<AsyncIterator<Boolean>>;
  babyMonitor: () => Promise<AsyncIterator<Boolean>>;
  babysitterRecommendations: () => Promise<AsyncIterator<Boolean>>;
  bathtub: () => Promise<AsyncIterator<Boolean>>;
  changingTable: () => Promise<AsyncIterator<Boolean>>;
  childrensBooksAndToys: () => Promise<AsyncIterator<Boolean>>;
  childrensDinnerware: () => Promise<AsyncIterator<Boolean>>;
  crib: () => Promise<AsyncIterator<Boolean>>;
}

export interface AggregateReviewNode {
  count: Int;
}

export interface AggregateReview
  extends Promise<AggregateReviewNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateReviewSubscription
  extends Promise<AsyncIterator<AggregateReviewNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AmenitiesSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface AmenitiesSubscriptionPayload
  extends Promise<AmenitiesSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = Amenities>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AmenitiesPreviousValues>() => T;
}

export interface AmenitiesSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AmenitiesSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AmenitiesSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AmenitiesPreviousValuesSubscription>() => T;
}

export interface ReviewConnectionNode {}

export interface ReviewConnection
  extends Promise<ReviewConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<ReviewEdgeNode>>() => T;
  aggregate: <T = AggregateReview>() => T;
}

export interface ReviewConnectionSubscription
  extends Promise<AsyncIterator<ReviewConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ReviewEdgeSubscription>>>() => T;
  aggregate: <T = AggregateReviewSubscription>() => T;
}

export interface AmenitiesPreviousValuesNode {
  id: ID_Output;
  elevator: Boolean;
  petsAllowed: Boolean;
  internet: Boolean;
  kitchen: Boolean;
  wirelessInternet: Boolean;
  familyKidFriendly: Boolean;
  freeParkingOnPremises: Boolean;
  hotTub: Boolean;
  pool: Boolean;
  smokingAllowed: Boolean;
  wheelchairAccessible: Boolean;
  breakfast: Boolean;
  cableTv: Boolean;
  suitableForEvents: Boolean;
  dryer: Boolean;
  washer: Boolean;
  indoorFireplace: Boolean;
  tv: Boolean;
  heating: Boolean;
  hangers: Boolean;
  iron: Boolean;
  hairDryer: Boolean;
  doorman: Boolean;
  paidParkingOffPremises: Boolean;
  freeParkingOnStreet: Boolean;
  gym: Boolean;
  airConditioning: Boolean;
  shampoo: Boolean;
  essentials: Boolean;
  laptopFriendlyWorkspace: Boolean;
  privateEntrance: Boolean;
  buzzerWirelessIntercom: Boolean;
  babyBath: Boolean;
  babyMonitor: Boolean;
  babysitterRecommendations: Boolean;
  bathtub: Boolean;
  changingTable: Boolean;
  childrensBooksAndToys: Boolean;
  childrensDinnerware: Boolean;
  crib: Boolean;
}

export interface AmenitiesPreviousValues
  extends Promise<AmenitiesPreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  elevator: () => Promise<Boolean>;
  petsAllowed: () => Promise<Boolean>;
  internet: () => Promise<Boolean>;
  kitchen: () => Promise<Boolean>;
  wirelessInternet: () => Promise<Boolean>;
  familyKidFriendly: () => Promise<Boolean>;
  freeParkingOnPremises: () => Promise<Boolean>;
  hotTub: () => Promise<Boolean>;
  pool: () => Promise<Boolean>;
  smokingAllowed: () => Promise<Boolean>;
  wheelchairAccessible: () => Promise<Boolean>;
  breakfast: () => Promise<Boolean>;
  cableTv: () => Promise<Boolean>;
  suitableForEvents: () => Promise<Boolean>;
  dryer: () => Promise<Boolean>;
  washer: () => Promise<Boolean>;
  indoorFireplace: () => Promise<Boolean>;
  tv: () => Promise<Boolean>;
  heating: () => Promise<Boolean>;
  hangers: () => Promise<Boolean>;
  iron: () => Promise<Boolean>;
  hairDryer: () => Promise<Boolean>;
  doorman: () => Promise<Boolean>;
  paidParkingOffPremises: () => Promise<Boolean>;
  freeParkingOnStreet: () => Promise<Boolean>;
  gym: () => Promise<Boolean>;
  airConditioning: () => Promise<Boolean>;
  shampoo: () => Promise<Boolean>;
  essentials: () => Promise<Boolean>;
  laptopFriendlyWorkspace: () => Promise<Boolean>;
  privateEntrance: () => Promise<Boolean>;
  buzzerWirelessIntercom: () => Promise<Boolean>;
  babyBath: () => Promise<Boolean>;
  babyMonitor: () => Promise<Boolean>;
  babysitterRecommendations: () => Promise<Boolean>;
  bathtub: () => Promise<Boolean>;
  changingTable: () => Promise<Boolean>;
  childrensBooksAndToys: () => Promise<Boolean>;
  childrensDinnerware: () => Promise<Boolean>;
  crib: () => Promise<Boolean>;
}

export interface AmenitiesPreviousValuesSubscription
  extends Promise<AsyncIterator<AmenitiesPreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  elevator: () => Promise<AsyncIterator<Boolean>>;
  petsAllowed: () => Promise<AsyncIterator<Boolean>>;
  internet: () => Promise<AsyncIterator<Boolean>>;
  kitchen: () => Promise<AsyncIterator<Boolean>>;
  wirelessInternet: () => Promise<AsyncIterator<Boolean>>;
  familyKidFriendly: () => Promise<AsyncIterator<Boolean>>;
  freeParkingOnPremises: () => Promise<AsyncIterator<Boolean>>;
  hotTub: () => Promise<AsyncIterator<Boolean>>;
  pool: () => Promise<AsyncIterator<Boolean>>;
  smokingAllowed: () => Promise<AsyncIterator<Boolean>>;
  wheelchairAccessible: () => Promise<AsyncIterator<Boolean>>;
  breakfast: () => Promise<AsyncIterator<Boolean>>;
  cableTv: () => Promise<AsyncIterator<Boolean>>;
  suitableForEvents: () => Promise<AsyncIterator<Boolean>>;
  dryer: () => Promise<AsyncIterator<Boolean>>;
  washer: () => Promise<AsyncIterator<Boolean>>;
  indoorFireplace: () => Promise<AsyncIterator<Boolean>>;
  tv: () => Promise<AsyncIterator<Boolean>>;
  heating: () => Promise<AsyncIterator<Boolean>>;
  hangers: () => Promise<AsyncIterator<Boolean>>;
  iron: () => Promise<AsyncIterator<Boolean>>;
  hairDryer: () => Promise<AsyncIterator<Boolean>>;
  doorman: () => Promise<AsyncIterator<Boolean>>;
  paidParkingOffPremises: () => Promise<AsyncIterator<Boolean>>;
  freeParkingOnStreet: () => Promise<AsyncIterator<Boolean>>;
  gym: () => Promise<AsyncIterator<Boolean>>;
  airConditioning: () => Promise<AsyncIterator<Boolean>>;
  shampoo: () => Promise<AsyncIterator<Boolean>>;
  essentials: () => Promise<AsyncIterator<Boolean>>;
  laptopFriendlyWorkspace: () => Promise<AsyncIterator<Boolean>>;
  privateEntrance: () => Promise<AsyncIterator<Boolean>>;
  buzzerWirelessIntercom: () => Promise<AsyncIterator<Boolean>>;
  babyBath: () => Promise<AsyncIterator<Boolean>>;
  babyMonitor: () => Promise<AsyncIterator<Boolean>>;
  babysitterRecommendations: () => Promise<AsyncIterator<Boolean>>;
  bathtub: () => Promise<AsyncIterator<Boolean>>;
  changingTable: () => Promise<AsyncIterator<Boolean>>;
  childrensBooksAndToys: () => Promise<AsyncIterator<Boolean>>;
  childrensDinnerware: () => Promise<AsyncIterator<Boolean>>;
  crib: () => Promise<AsyncIterator<Boolean>>;
}

export interface RestaurantEdgeNode {
  cursor: String;
}

export interface RestaurantEdge
  extends Promise<RestaurantEdgeNode>,
    Fragmentable {
  node: <T = Restaurant>() => T;
  cursor: () => Promise<String>;
}

export interface RestaurantEdgeSubscription
  extends Promise<AsyncIterator<RestaurantEdgeNode>>,
    Fragmentable {
  node: <T = RestaurantSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateAmenitiesNode {
  count: Int;
}

export interface AggregateAmenities
  extends Promise<AggregateAmenitiesNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAmenitiesSubscription
  extends Promise<AsyncIterator<AggregateAmenitiesNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserNode {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  firstName: String;
  lastName: String;
  email: String;
  password: String;
  phone: String;
  responseRate?: Float;
  responseTime?: Int;
  isSuperHost: Boolean;
}

export interface User extends Promise<UserNode>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  phone: () => Promise<String>;
  responseRate: () => Promise<Float>;
  responseTime: () => Promise<Int>;
  isSuperHost: () => Promise<Boolean>;
  ownedPlaces: <T = FragmentableArray<PlaceNode>>(
    args?: {
      where?: PlaceWhereInput;
      orderBy?: PlaceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  location: <T = Location>() => T;
  bookings: <T = FragmentableArray<BookingNode>>(
    args?: {
      where?: BookingWhereInput;
      orderBy?: BookingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  paymentAccount: <T = FragmentableArray<PaymentAccountNode>>(
    args?: {
      where?: PaymentAccountWhereInput;
      orderBy?: PaymentAccountOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  sentMessages: <T = FragmentableArray<MessageNode>>(
    args?: {
      where?: MessageWhereInput;
      orderBy?: MessageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  receivedMessages: <T = FragmentableArray<MessageNode>>(
    args?: {
      where?: MessageWhereInput;
      orderBy?: MessageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  notifications: <T = FragmentableArray<NotificationNode>>(
    args?: {
      where?: NotificationWhereInput;
      orderBy?: NotificationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  profilePicture: <T = Picture>() => T;
  hostingExperiences: <T = FragmentableArray<ExperienceNode>>(
    args?: {
      where?: ExperienceWhereInput;
      orderBy?: ExperienceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface UserSubscription
  extends Promise<AsyncIterator<UserNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  responseRate: () => Promise<AsyncIterator<Float>>;
  responseTime: () => Promise<AsyncIterator<Int>>;
  isSuperHost: () => Promise<AsyncIterator<Boolean>>;
  ownedPlaces: <T = Promise<AsyncIterator<PlaceSubscription>>>(
    args?: {
      where?: PlaceWhereInput;
      orderBy?: PlaceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  location: <T = LocationSubscription>() => T;
  bookings: <T = Promise<AsyncIterator<BookingSubscription>>>(
    args?: {
      where?: BookingWhereInput;
      orderBy?: BookingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  paymentAccount: <T = Promise<AsyncIterator<PaymentAccountSubscription>>>(
    args?: {
      where?: PaymentAccountWhereInput;
      orderBy?: PaymentAccountOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  sentMessages: <T = Promise<AsyncIterator<MessageSubscription>>>(
    args?: {
      where?: MessageWhereInput;
      orderBy?: MessageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  receivedMessages: <T = Promise<AsyncIterator<MessageSubscription>>>(
    args?: {
      where?: MessageWhereInput;
      orderBy?: MessageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  notifications: <T = Promise<AsyncIterator<NotificationSubscription>>>(
    args?: {
      where?: NotificationWhereInput;
      orderBy?: NotificationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  profilePicture: <T = PictureSubscription>() => T;
  hostingExperiences: <T = Promise<AsyncIterator<ExperienceSubscription>>>(
    args?: {
      where?: ExperienceWhereInput;
      orderBy?: ExperienceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface BookingSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface BookingSubscriptionPayload
  extends Promise<BookingSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = Booking>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BookingPreviousValues>() => T;
}

export interface BookingSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BookingSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BookingSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BookingPreviousValuesSubscription>() => T;
}

export interface PricingEdgeNode {
  cursor: String;
}

export interface PricingEdge extends Promise<PricingEdgeNode>, Fragmentable {
  node: <T = Pricing>() => T;
  cursor: () => Promise<String>;
}

export interface PricingEdgeSubscription
  extends Promise<AsyncIterator<PricingEdgeNode>>,
    Fragmentable {
  node: <T = PricingSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface BookingPreviousValuesNode {
  id: ID_Output;
  createdAt: DateTimeOutput;
  startDate: DateTimeOutput;
  endDate: DateTimeOutput;
}

export interface BookingPreviousValues
  extends Promise<BookingPreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  startDate: () => Promise<DateTimeOutput>;
  endDate: () => Promise<DateTimeOutput>;
}

export interface BookingPreviousValuesSubscription
  extends Promise<AsyncIterator<BookingPreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  startDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  endDate: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregatePoliciesNode {
  count: Int;
}

export interface AggregatePolicies
  extends Promise<AggregatePoliciesNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePoliciesSubscription
  extends Promise<AsyncIterator<AggregatePoliciesNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AmenitiesEdgeNode {
  cursor: String;
}

export interface AmenitiesEdge
  extends Promise<AmenitiesEdgeNode>,
    Fragmentable {
  node: <T = Amenities>() => T;
  cursor: () => Promise<String>;
}

export interface AmenitiesEdgeSubscription
  extends Promise<AsyncIterator<AmenitiesEdgeNode>>,
    Fragmentable {
  node: <T = AmenitiesSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PoliciesConnectionNode {}

export interface PoliciesConnection
  extends Promise<PoliciesConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<PoliciesEdgeNode>>() => T;
  aggregate: <T = AggregatePolicies>() => T;
}

export interface PoliciesConnectionSubscription
  extends Promise<AsyncIterator<PoliciesConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PoliciesEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePoliciesSubscription>() => T;
}

export interface CitySubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface CitySubscriptionPayload
  extends Promise<CitySubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = City>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CityPreviousValues>() => T;
}

export interface CitySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CitySubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CitySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CityPreviousValuesSubscription>() => T;
}

export interface AggregatePlaceNode {
  count: Int;
}

export interface AggregatePlace
  extends Promise<AggregatePlaceNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePlaceSubscription
  extends Promise<AsyncIterator<AggregatePlaceNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CityPreviousValuesNode {
  id: ID_Output;
  name: String;
}

export interface CityPreviousValues
  extends Promise<CityPreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface CityPreviousValuesSubscription
  extends Promise<AsyncIterator<CityPreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface PlaceConnectionNode {}

export interface PlaceConnection
  extends Promise<PlaceConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<PlaceEdgeNode>>() => T;
  aggregate: <T = AggregatePlace>() => T;
}

export interface PlaceConnectionSubscription
  extends Promise<AsyncIterator<PlaceConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PlaceEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePlaceSubscription>() => T;
}

export interface PageInfoNode {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfo extends Promise<PageInfoNode>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfoNode>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface PictureEdgeNode {
  cursor: String;
}

export interface PictureEdge extends Promise<PictureEdgeNode>, Fragmentable {
  node: <T = Picture>() => T;
  cursor: () => Promise<String>;
}

export interface PictureEdgeSubscription
  extends Promise<AsyncIterator<PictureEdgeNode>>,
    Fragmentable {
  node: <T = PictureSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CreditCardInformationSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface CreditCardInformationSubscriptionPayload
  extends Promise<CreditCardInformationSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CreditCardInformation>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CreditCardInformationPreviousValues>() => T;
}

export interface CreditCardInformationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CreditCardInformationSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CreditCardInformationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CreditCardInformationPreviousValuesSubscription>() => T;
}

export interface AggregatePaypalInformationNode {
  count: Int;
}

export interface AggregatePaypalInformation
  extends Promise<AggregatePaypalInformationNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePaypalInformationSubscription
  extends Promise<AsyncIterator<AggregatePaypalInformationNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CreditCardInformationPreviousValuesNode {
  id: ID_Output;
  createdAt: DateTimeOutput;
  cardNumber: String;
  expiresOnMonth: Int;
  expiresOnYear: Int;
  securityCode: String;
  firstName: String;
  lastName: String;
  postalCode: String;
  country: String;
}

export interface CreditCardInformationPreviousValues
  extends Promise<CreditCardInformationPreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  cardNumber: () => Promise<String>;
  expiresOnMonth: () => Promise<Int>;
  expiresOnYear: () => Promise<Int>;
  securityCode: () => Promise<String>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  postalCode: () => Promise<String>;
  country: () => Promise<String>;
}

export interface CreditCardInformationPreviousValuesSubscription
  extends Promise<AsyncIterator<CreditCardInformationPreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  cardNumber: () => Promise<AsyncIterator<String>>;
  expiresOnMonth: () => Promise<AsyncIterator<Int>>;
  expiresOnYear: () => Promise<AsyncIterator<Int>>;
  securityCode: () => Promise<AsyncIterator<String>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  postalCode: () => Promise<AsyncIterator<String>>;
  country: () => Promise<AsyncIterator<String>>;
}

export interface PaypalInformationConnectionNode {}

export interface PaypalInformationConnection
  extends Promise<PaypalInformationConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<PaypalInformationEdgeNode>>() => T;
  aggregate: <T = AggregatePaypalInformation>() => T;
}

export interface PaypalInformationConnectionSubscription
  extends Promise<AsyncIterator<PaypalInformationConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PaypalInformationEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePaypalInformationSubscription>() => T;
}

export interface AmenitiesConnectionNode {}

export interface AmenitiesConnection
  extends Promise<AmenitiesConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<AmenitiesEdgeNode>>() => T;
  aggregate: <T = AggregateAmenities>() => T;
}

export interface AmenitiesConnectionSubscription
  extends Promise<AsyncIterator<AmenitiesConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AmenitiesEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAmenitiesSubscription>() => T;
}

export interface PaymentAccountEdgeNode {
  cursor: String;
}

export interface PaymentAccountEdge
  extends Promise<PaymentAccountEdgeNode>,
    Fragmentable {
  node: <T = PaymentAccount>() => T;
  cursor: () => Promise<String>;
}

export interface PaymentAccountEdgeSubscription
  extends Promise<AsyncIterator<PaymentAccountEdgeNode>>,
    Fragmentable {
  node: <T = PaymentAccountSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ExperienceSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface ExperienceSubscriptionPayload
  extends Promise<ExperienceSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = Experience>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ExperiencePreviousValues>() => T;
}

export interface ExperienceSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ExperienceSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ExperienceSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ExperiencePreviousValuesSubscription>() => T;
}

export interface AggregatePaymentNode {
  count: Int;
}

export interface AggregatePayment
  extends Promise<AggregatePaymentNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePaymentSubscription
  extends Promise<AsyncIterator<AggregatePaymentNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ExperiencePreviousValuesNode {
  id: ID_Output;
  title: String;
  pricePerPerson: Int;
  popularity: Int;
}

export interface ExperiencePreviousValues
  extends Promise<ExperiencePreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  pricePerPerson: () => Promise<Int>;
  popularity: () => Promise<Int>;
}

export interface ExperiencePreviousValuesSubscription
  extends Promise<AsyncIterator<ExperiencePreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  pricePerPerson: () => Promise<AsyncIterator<Int>>;
  popularity: () => Promise<AsyncIterator<Int>>;
}

export interface PaymentConnectionNode {}

export interface PaymentConnection
  extends Promise<PaymentConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<PaymentEdgeNode>>() => T;
  aggregate: <T = AggregatePayment>() => T;
}

export interface PaymentConnectionSubscription
  extends Promise<AsyncIterator<PaymentConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PaymentEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePaymentSubscription>() => T;
}

export interface HouseRulesNode {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  suitableForChildren?: Boolean;
  suitableForInfants?: Boolean;
  petsAllowed?: Boolean;
  smokingAllowed?: Boolean;
  partiesAndEventsAllowed?: Boolean;
  additionalRules?: String;
}

export interface HouseRules extends Promise<HouseRulesNode>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  suitableForChildren: () => Promise<Boolean>;
  suitableForInfants: () => Promise<Boolean>;
  petsAllowed: () => Promise<Boolean>;
  smokingAllowed: () => Promise<Boolean>;
  partiesAndEventsAllowed: () => Promise<Boolean>;
  additionalRules: () => Promise<String>;
}

export interface HouseRulesSubscription
  extends Promise<AsyncIterator<HouseRulesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  suitableForChildren: () => Promise<AsyncIterator<Boolean>>;
  suitableForInfants: () => Promise<AsyncIterator<Boolean>>;
  petsAllowed: () => Promise<AsyncIterator<Boolean>>;
  smokingAllowed: () => Promise<AsyncIterator<Boolean>>;
  partiesAndEventsAllowed: () => Promise<AsyncIterator<Boolean>>;
  additionalRules: () => Promise<AsyncIterator<String>>;
}

export interface NotificationEdgeNode {
  cursor: String;
}

export interface NotificationEdge
  extends Promise<NotificationEdgeNode>,
    Fragmentable {
  node: <T = Notification>() => T;
  cursor: () => Promise<String>;
}

export interface NotificationEdgeSubscription
  extends Promise<AsyncIterator<NotificationEdgeNode>>,
    Fragmentable {
  node: <T = NotificationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ExperienceCategorySubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface ExperienceCategorySubscriptionPayload
  extends Promise<ExperienceCategorySubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ExperienceCategory>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ExperienceCategoryPreviousValues>() => T;
}

export interface ExperienceCategorySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ExperienceCategorySubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ExperienceCategorySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ExperienceCategoryPreviousValuesSubscription>() => T;
}

export interface AggregateNeighbourhoodNode {
  count: Int;
}

export interface AggregateNeighbourhood
  extends Promise<AggregateNeighbourhoodNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateNeighbourhoodSubscription
  extends Promise<AsyncIterator<AggregateNeighbourhoodNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ExperienceCategoryPreviousValuesNode {
  id: ID_Output;
  mainColor: String;
  name: String;
}

export interface ExperienceCategoryPreviousValues
  extends Promise<ExperienceCategoryPreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  mainColor: () => Promise<String>;
  name: () => Promise<String>;
}

export interface ExperienceCategoryPreviousValuesSubscription
  extends Promise<AsyncIterator<ExperienceCategoryPreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  mainColor: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface NeighbourhoodConnectionNode {}

export interface NeighbourhoodConnection
  extends Promise<NeighbourhoodConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<NeighbourhoodEdgeNode>>() => T;
  aggregate: <T = AggregateNeighbourhood>() => T;
}

export interface NeighbourhoodConnectionSubscription
  extends Promise<AsyncIterator<NeighbourhoodConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<NeighbourhoodEdgeSubscription>>>() => T;
  aggregate: <T = AggregateNeighbourhoodSubscription>() => T;
}

export interface PoliciesNode {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  checkInStartTime: Float;
  checkInEndTime: Float;
  checkoutTime: Float;
}

export interface Policies extends Promise<PoliciesNode>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  checkInStartTime: () => Promise<Float>;
  checkInEndTime: () => Promise<Float>;
  checkoutTime: () => Promise<Float>;
  place: <T = Place>() => T;
}

export interface PoliciesSubscription
  extends Promise<AsyncIterator<PoliciesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  checkInStartTime: () => Promise<AsyncIterator<Float>>;
  checkInEndTime: () => Promise<AsyncIterator<Float>>;
  checkoutTime: () => Promise<AsyncIterator<Float>>;
  place: <T = PlaceSubscription>() => T;
}

export interface MessageEdgeNode {
  cursor: String;
}

export interface MessageEdge extends Promise<MessageEdgeNode>, Fragmentable {
  node: <T = Message>() => T;
  cursor: () => Promise<String>;
}

export interface MessageEdgeSubscription
  extends Promise<AsyncIterator<MessageEdgeNode>>,
    Fragmentable {
  node: <T = MessageSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface GuestRequirementsSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface GuestRequirementsSubscriptionPayload
  extends Promise<GuestRequirementsSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = GuestRequirements>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = GuestRequirementsPreviousValues>() => T;
}

export interface GuestRequirementsSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GuestRequirementsSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GuestRequirementsSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = GuestRequirementsPreviousValuesSubscription>() => T;
}

export interface AggregateLocationNode {
  count: Int;
}

export interface AggregateLocation
  extends Promise<AggregateLocationNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateLocationSubscription
  extends Promise<AsyncIterator<AggregateLocationNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface GuestRequirementsPreviousValuesNode {
  id: ID_Output;
  govIssuedId: Boolean;
  recommendationsFromOtherHosts: Boolean;
  guestTripInformation: Boolean;
}

export interface GuestRequirementsPreviousValues
  extends Promise<GuestRequirementsPreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  govIssuedId: () => Promise<Boolean>;
  recommendationsFromOtherHosts: () => Promise<Boolean>;
  guestTripInformation: () => Promise<Boolean>;
}

export interface GuestRequirementsPreviousValuesSubscription
  extends Promise<AsyncIterator<GuestRequirementsPreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  govIssuedId: () => Promise<AsyncIterator<Boolean>>;
  recommendationsFromOtherHosts: () => Promise<AsyncIterator<Boolean>>;
  guestTripInformation: () => Promise<AsyncIterator<Boolean>>;
}

export interface LocationConnectionNode {}

export interface LocationConnection
  extends Promise<LocationConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<LocationEdgeNode>>() => T;
  aggregate: <T = AggregateLocation>() => T;
}

export interface LocationConnectionSubscription
  extends Promise<AsyncIterator<LocationConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<LocationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateLocationSubscription>() => T;
}

export interface GuestRequirementsNode {
  id: ID_Output;
  govIssuedId: Boolean;
  recommendationsFromOtherHosts: Boolean;
  guestTripInformation: Boolean;
}

export interface GuestRequirements
  extends Promise<GuestRequirementsNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  govIssuedId: () => Promise<Boolean>;
  recommendationsFromOtherHosts: () => Promise<Boolean>;
  guestTripInformation: () => Promise<Boolean>;
  place: <T = Place>() => T;
}

export interface GuestRequirementsSubscription
  extends Promise<AsyncIterator<GuestRequirementsNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  govIssuedId: () => Promise<AsyncIterator<Boolean>>;
  recommendationsFromOtherHosts: () => Promise<AsyncIterator<Boolean>>;
  guestTripInformation: () => Promise<AsyncIterator<Boolean>>;
  place: <T = PlaceSubscription>() => T;
}

export interface HouseRulesEdgeNode {
  cursor: String;
}

export interface HouseRulesEdge
  extends Promise<HouseRulesEdgeNode>,
    Fragmentable {
  node: <T = HouseRules>() => T;
  cursor: () => Promise<String>;
}

export interface HouseRulesEdgeSubscription
  extends Promise<AsyncIterator<HouseRulesEdgeNode>>,
    Fragmentable {
  node: <T = HouseRulesSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface HouseRulesSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface HouseRulesSubscriptionPayload
  extends Promise<HouseRulesSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = HouseRules>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = HouseRulesPreviousValues>() => T;
}

export interface HouseRulesSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<HouseRulesSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = HouseRulesSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = HouseRulesPreviousValuesSubscription>() => T;
}

export interface AggregateGuestRequirementsNode {
  count: Int;
}

export interface AggregateGuestRequirements
  extends Promise<AggregateGuestRequirementsNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateGuestRequirementsSubscription
  extends Promise<AsyncIterator<AggregateGuestRequirementsNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface HouseRulesPreviousValuesNode {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  suitableForChildren?: Boolean;
  suitableForInfants?: Boolean;
  petsAllowed?: Boolean;
  smokingAllowed?: Boolean;
  partiesAndEventsAllowed?: Boolean;
  additionalRules?: String;
}

export interface HouseRulesPreviousValues
  extends Promise<HouseRulesPreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  suitableForChildren: () => Promise<Boolean>;
  suitableForInfants: () => Promise<Boolean>;
  petsAllowed: () => Promise<Boolean>;
  smokingAllowed: () => Promise<Boolean>;
  partiesAndEventsAllowed: () => Promise<Boolean>;
  additionalRules: () => Promise<String>;
}

export interface HouseRulesPreviousValuesSubscription
  extends Promise<AsyncIterator<HouseRulesPreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  suitableForChildren: () => Promise<AsyncIterator<Boolean>>;
  suitableForInfants: () => Promise<AsyncIterator<Boolean>>;
  petsAllowed: () => Promise<AsyncIterator<Boolean>>;
  smokingAllowed: () => Promise<AsyncIterator<Boolean>>;
  partiesAndEventsAllowed: () => Promise<AsyncIterator<Boolean>>;
  additionalRules: () => Promise<AsyncIterator<String>>;
}

export interface GuestRequirementsConnectionNode {}

export interface GuestRequirementsConnection
  extends Promise<GuestRequirementsConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<GuestRequirementsEdgeNode>>() => T;
  aggregate: <T = AggregateGuestRequirements>() => T;
}

export interface GuestRequirementsConnectionSubscription
  extends Promise<AsyncIterator<GuestRequirementsConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<GuestRequirementsEdgeSubscription>>>() => T;
  aggregate: <T = AggregateGuestRequirementsSubscription>() => T;
}

export interface ViewsNode {
  id: ID_Output;
  lastWeek: Int;
}

export interface Views extends Promise<ViewsNode>, Fragmentable {
  id: () => Promise<ID_Output>;
  lastWeek: () => Promise<Int>;
  place: <T = Place>() => T;
}

export interface ViewsSubscription
  extends Promise<AsyncIterator<ViewsNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  lastWeek: () => Promise<AsyncIterator<Int>>;
  place: <T = PlaceSubscription>() => T;
}

export interface AggregateExperienceCategoryNode {
  count: Int;
}

export interface AggregateExperienceCategory
  extends Promise<AggregateExperienceCategoryNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateExperienceCategorySubscription
  extends Promise<AsyncIterator<AggregateExperienceCategoryNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface LocationSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface LocationSubscriptionPayload
  extends Promise<LocationSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = Location>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = LocationPreviousValues>() => T;
}

export interface LocationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<LocationSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = LocationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = LocationPreviousValuesSubscription>() => T;
}

export interface ExperienceCategoryConnectionNode {}

export interface ExperienceCategoryConnection
  extends Promise<ExperienceCategoryConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<ExperienceCategoryEdgeNode>>() => T;
  aggregate: <T = AggregateExperienceCategory>() => T;
}

export interface ExperienceCategoryConnectionSubscription
  extends Promise<AsyncIterator<ExperienceCategoryConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<ExperienceCategoryEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateExperienceCategorySubscription>() => T;
}

export interface LocationPreviousValuesNode {
  id: ID_Output;
  lat: Float;
  lng: Float;
  address: String;
  directions: String;
}

export interface LocationPreviousValues
  extends Promise<LocationPreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  lat: () => Promise<Float>;
  lng: () => Promise<Float>;
  address: () => Promise<String>;
  directions: () => Promise<String>;
}

export interface LocationPreviousValuesSubscription
  extends Promise<AsyncIterator<LocationPreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  lat: () => Promise<AsyncIterator<Float>>;
  lng: () => Promise<AsyncIterator<Float>>;
  address: () => Promise<AsyncIterator<String>>;
  directions: () => Promise<AsyncIterator<String>>;
}

export interface ExperienceEdgeNode {
  cursor: String;
}

export interface ExperienceEdge
  extends Promise<ExperienceEdgeNode>,
    Fragmentable {
  node: <T = Experience>() => T;
  cursor: () => Promise<String>;
}

export interface ExperienceEdgeSubscription
  extends Promise<AsyncIterator<ExperienceEdgeNode>>,
    Fragmentable {
  node: <T = ExperienceSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PricingNode {
  id: ID_Output;
  monthlyDiscount?: Int;
  weeklyDiscount?: Int;
  perNight: Int;
  smartPricing: Boolean;
  basePrice: Int;
  averageWeekly: Int;
  averageMonthly: Int;
  cleaningFee?: Int;
  securityDeposit?: Int;
  extraGuests?: Int;
  weekendPricing?: Int;
  currency?: CURRENCY;
}

export interface Pricing extends Promise<PricingNode>, Fragmentable {
  id: () => Promise<ID_Output>;
  place: <T = Place>() => T;
  monthlyDiscount: () => Promise<Int>;
  weeklyDiscount: () => Promise<Int>;
  perNight: () => Promise<Int>;
  smartPricing: () => Promise<Boolean>;
  basePrice: () => Promise<Int>;
  averageWeekly: () => Promise<Int>;
  averageMonthly: () => Promise<Int>;
  cleaningFee: () => Promise<Int>;
  securityDeposit: () => Promise<Int>;
  extraGuests: () => Promise<Int>;
  weekendPricing: () => Promise<Int>;
  currency: () => Promise<CURRENCY>;
}

export interface PricingSubscription
  extends Promise<AsyncIterator<PricingNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  place: <T = PlaceSubscription>() => T;
  monthlyDiscount: () => Promise<AsyncIterator<Int>>;
  weeklyDiscount: () => Promise<AsyncIterator<Int>>;
  perNight: () => Promise<AsyncIterator<Int>>;
  smartPricing: () => Promise<AsyncIterator<Boolean>>;
  basePrice: () => Promise<AsyncIterator<Int>>;
  averageWeekly: () => Promise<AsyncIterator<Int>>;
  averageMonthly: () => Promise<AsyncIterator<Int>>;
  cleaningFee: () => Promise<AsyncIterator<Int>>;
  securityDeposit: () => Promise<AsyncIterator<Int>>;
  extraGuests: () => Promise<AsyncIterator<Int>>;
  weekendPricing: () => Promise<AsyncIterator<Int>>;
  currency: () => Promise<AsyncIterator<CURRENCY>>;
}

export interface AggregateCreditCardInformationNode {
  count: Int;
}

export interface AggregateCreditCardInformation
  extends Promise<AggregateCreditCardInformationNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCreditCardInformationSubscription
  extends Promise<AsyncIterator<AggregateCreditCardInformationNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface MessageSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface MessageSubscriptionPayload
  extends Promise<MessageSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = Message>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MessagePreviousValues>() => T;
}

export interface MessageSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MessageSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MessageSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MessagePreviousValuesSubscription>() => T;
}

export interface CreditCardInformationConnectionNode {}

export interface CreditCardInformationConnection
  extends Promise<CreditCardInformationConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<CreditCardInformationEdgeNode>>() => T;
  aggregate: <T = AggregateCreditCardInformation>() => T;
}

export interface CreditCardInformationConnectionSubscription
  extends Promise<AsyncIterator<CreditCardInformationConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<CreditCardInformationEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateCreditCardInformationSubscription>() => T;
}

export interface MessagePreviousValuesNode {
  id: ID_Output;
  createdAt: DateTimeOutput;
  deliveredAt: DateTimeOutput;
  readAt: DateTimeOutput;
}

export interface MessagePreviousValues
  extends Promise<MessagePreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  deliveredAt: () => Promise<DateTimeOutput>;
  readAt: () => Promise<DateTimeOutput>;
}

export interface MessagePreviousValuesSubscription
  extends Promise<AsyncIterator<MessagePreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  deliveredAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  readAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateCityNode {
  count: Int;
}

export interface AggregateCity
  extends Promise<AggregateCityNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCitySubscription
  extends Promise<AsyncIterator<AggregateCityNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface NotificationNode {
  id: ID_Output;
  createdAt: DateTimeOutput;
  type?: NOTIFICATION_TYPE;
  link: String;
  readDate: DateTimeOutput;
}

export interface Notification extends Promise<NotificationNode>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  type: () => Promise<NOTIFICATION_TYPE>;
  user: <T = User>() => T;
  link: () => Promise<String>;
  readDate: () => Promise<DateTimeOutput>;
}

export interface NotificationSubscription
  extends Promise<AsyncIterator<NotificationNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  type: () => Promise<AsyncIterator<NOTIFICATION_TYPE>>;
  user: <T = UserSubscription>() => T;
  link: () => Promise<AsyncIterator<String>>;
  readDate: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PlaceNode {
  id: ID_Output;
  name: String;
  size?: PLACE_SIZES;
  shortDescription: String;
  description: String;
  slug: String;
  maxGuests: Int;
  numBedrooms: Int;
  numBeds: Int;
  numBaths: Int;
  popularity: Int;
}

export interface Place extends Promise<PlaceNode>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  size: () => Promise<PLACE_SIZES>;
  shortDescription: () => Promise<String>;
  description: () => Promise<String>;
  slug: () => Promise<String>;
  maxGuests: () => Promise<Int>;
  numBedrooms: () => Promise<Int>;
  numBeds: () => Promise<Int>;
  numBaths: () => Promise<Int>;
  reviews: <T = FragmentableArray<ReviewNode>>(
    args?: {
      where?: ReviewWhereInput;
      orderBy?: ReviewOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  amenities: <T = Amenities>() => T;
  host: <T = User>() => T;
  pricing: <T = Pricing>() => T;
  location: <T = Location>() => T;
  views: <T = Views>() => T;
  guestRequirements: <T = GuestRequirements>() => T;
  policies: <T = Policies>() => T;
  houseRules: <T = HouseRules>() => T;
  bookings: <T = FragmentableArray<BookingNode>>(
    args?: {
      where?: BookingWhereInput;
      orderBy?: BookingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  pictures: <T = FragmentableArray<PictureNode>>(
    args?: {
      where?: PictureWhereInput;
      orderBy?: PictureOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  popularity: () => Promise<Int>;
}

export interface PlaceSubscription
  extends Promise<AsyncIterator<PlaceNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  size: () => Promise<AsyncIterator<PLACE_SIZES>>;
  shortDescription: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  slug: () => Promise<AsyncIterator<String>>;
  maxGuests: () => Promise<AsyncIterator<Int>>;
  numBedrooms: () => Promise<AsyncIterator<Int>>;
  numBeds: () => Promise<AsyncIterator<Int>>;
  numBaths: () => Promise<AsyncIterator<Int>>;
  reviews: <T = Promise<AsyncIterator<ReviewSubscription>>>(
    args?: {
      where?: ReviewWhereInput;
      orderBy?: ReviewOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  amenities: <T = AmenitiesSubscription>() => T;
  host: <T = UserSubscription>() => T;
  pricing: <T = PricingSubscription>() => T;
  location: <T = LocationSubscription>() => T;
  views: <T = ViewsSubscription>() => T;
  guestRequirements: <T = GuestRequirementsSubscription>() => T;
  policies: <T = PoliciesSubscription>() => T;
  houseRules: <T = HouseRulesSubscription>() => T;
  bookings: <T = Promise<AsyncIterator<BookingSubscription>>>(
    args?: {
      where?: BookingWhereInput;
      orderBy?: BookingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  pictures: <T = Promise<AsyncIterator<PictureSubscription>>>(
    args?: {
      where?: PictureWhereInput;
      orderBy?: PictureOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  popularity: () => Promise<AsyncIterator<Int>>;
}

export interface NeighbourhoodSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface NeighbourhoodSubscriptionPayload
  extends Promise<NeighbourhoodSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = Neighbourhood>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = NeighbourhoodPreviousValues>() => T;
}

export interface NeighbourhoodSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<NeighbourhoodSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = NeighbourhoodSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = NeighbourhoodPreviousValuesSubscription>() => T;
}

export interface ViewsSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface ViewsSubscriptionPayload
  extends Promise<ViewsSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = Views>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ViewsPreviousValues>() => T;
}

export interface ViewsSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ViewsSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ViewsSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ViewsPreviousValuesSubscription>() => T;
}

export interface NeighbourhoodPreviousValuesNode {
  id: ID_Output;
  name: String;
  slug: String;
  featured: Boolean;
  popularity: Int;
}

export interface NeighbourhoodPreviousValues
  extends Promise<NeighbourhoodPreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  slug: () => Promise<String>;
  featured: () => Promise<Boolean>;
  popularity: () => Promise<Int>;
}

export interface NeighbourhoodPreviousValuesSubscription
  extends Promise<AsyncIterator<NeighbourhoodPreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  slug: () => Promise<AsyncIterator<String>>;
  featured: () => Promise<AsyncIterator<Boolean>>;
  popularity: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateRestaurantNode {
  count: Int;
}

export interface AggregateRestaurant
  extends Promise<AggregateRestaurantNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateRestaurantSubscription
  extends Promise<AsyncIterator<AggregateRestaurantNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface MessageNode {
  id: ID_Output;
  createdAt: DateTimeOutput;
  deliveredAt: DateTimeOutput;
  readAt: DateTimeOutput;
}

export interface Message extends Promise<MessageNode>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  from: <T = User>() => T;
  to: <T = User>() => T;
  deliveredAt: () => Promise<DateTimeOutput>;
  readAt: () => Promise<DateTimeOutput>;
}

export interface MessageSubscription
  extends Promise<AsyncIterator<MessageNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  from: <T = UserSubscription>() => T;
  to: <T = UserSubscription>() => T;
  deliveredAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  readAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregatePricingNode {
  count: Int;
}

export interface AggregatePricing
  extends Promise<AggregatePricingNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePricingSubscription
  extends Promise<AsyncIterator<AggregatePricingNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface NotificationSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface NotificationSubscriptionPayload
  extends Promise<NotificationSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = Notification>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = NotificationPreviousValues>() => T;
}

export interface NotificationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<NotificationSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = NotificationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = NotificationPreviousValuesSubscription>() => T;
}

export interface PoliciesEdgeNode {
  cursor: String;
}

export interface PoliciesEdge extends Promise<PoliciesEdgeNode>, Fragmentable {
  node: <T = Policies>() => T;
  cursor: () => Promise<String>;
}

export interface PoliciesEdgeSubscription
  extends Promise<AsyncIterator<PoliciesEdgeNode>>,
    Fragmentable {
  node: <T = PoliciesSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface NotificationPreviousValuesNode {
  id: ID_Output;
  createdAt: DateTimeOutput;
  type?: NOTIFICATION_TYPE;
  link: String;
  readDate: DateTimeOutput;
}

export interface NotificationPreviousValues
  extends Promise<NotificationPreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  type: () => Promise<NOTIFICATION_TYPE>;
  link: () => Promise<String>;
  readDate: () => Promise<DateTimeOutput>;
}

export interface NotificationPreviousValuesSubscription
  extends Promise<AsyncIterator<NotificationPreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  type: () => Promise<AsyncIterator<NOTIFICATION_TYPE>>;
  link: () => Promise<AsyncIterator<String>>;
  readDate: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PlaceEdgeNode {
  cursor: String;
}

export interface PlaceEdge extends Promise<PlaceEdgeNode>, Fragmentable {
  node: <T = Place>() => T;
  cursor: () => Promise<String>;
}

export interface PlaceEdgeSubscription
  extends Promise<AsyncIterator<PlaceEdgeNode>>,
    Fragmentable {
  node: <T = PlaceSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CreditCardInformationNode {
  id: ID_Output;
  createdAt: DateTimeOutput;
  cardNumber: String;
  expiresOnMonth: Int;
  expiresOnYear: Int;
  securityCode: String;
  firstName: String;
  lastName: String;
  postalCode: String;
  country: String;
}

export interface CreditCardInformation
  extends Promise<CreditCardInformationNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  cardNumber: () => Promise<String>;
  expiresOnMonth: () => Promise<Int>;
  expiresOnYear: () => Promise<Int>;
  securityCode: () => Promise<String>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  postalCode: () => Promise<String>;
  country: () => Promise<String>;
  paymentAccount: <T = PaymentAccount>() => T;
}

export interface CreditCardInformationSubscription
  extends Promise<AsyncIterator<CreditCardInformationNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  cardNumber: () => Promise<AsyncIterator<String>>;
  expiresOnMonth: () => Promise<AsyncIterator<Int>>;
  expiresOnYear: () => Promise<AsyncIterator<Int>>;
  securityCode: () => Promise<AsyncIterator<String>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  postalCode: () => Promise<AsyncIterator<String>>;
  country: () => Promise<AsyncIterator<String>>;
  paymentAccount: <T = PaymentAccountSubscription>() => T;
}

export interface PictureConnectionNode {}

export interface PictureConnection
  extends Promise<PictureConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<PictureEdgeNode>>() => T;
  aggregate: <T = AggregatePicture>() => T;
}

export interface PictureConnectionSubscription
  extends Promise<AsyncIterator<PictureConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PictureEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePictureSubscription>() => T;
}

export interface PaymentSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface PaymentSubscriptionPayload
  extends Promise<PaymentSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = Payment>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PaymentPreviousValues>() => T;
}

export interface PaymentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PaymentSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PaymentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PaymentPreviousValuesSubscription>() => T;
}

export interface AggregatePaymentAccountNode {
  count: Int;
}

export interface AggregatePaymentAccount
  extends Promise<AggregatePaymentAccountNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePaymentAccountSubscription
  extends Promise<AsyncIterator<AggregatePaymentAccountNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PaymentPreviousValuesNode {
  id: ID_Output;
  createdAt: DateTimeOutput;
  serviceFee: Float;
  placePrice: Float;
  totalPrice: Float;
}

export interface PaymentPreviousValues
  extends Promise<PaymentPreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  serviceFee: () => Promise<Float>;
  placePrice: () => Promise<Float>;
  totalPrice: () => Promise<Float>;
}

export interface PaymentPreviousValuesSubscription
  extends Promise<AsyncIterator<PaymentPreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  serviceFee: () => Promise<AsyncIterator<Float>>;
  placePrice: () => Promise<AsyncIterator<Float>>;
  totalPrice: () => Promise<AsyncIterator<Float>>;
}

export interface PaymentEdgeNode {
  cursor: String;
}

export interface PaymentEdge extends Promise<PaymentEdgeNode>, Fragmentable {
  node: <T = Payment>() => T;
  cursor: () => Promise<String>;
}

export interface PaymentEdgeSubscription
  extends Promise<AsyncIterator<PaymentEdgeNode>>,
    Fragmentable {
  node: <T = PaymentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PaypalInformationNode {
  id: ID_Output;
  createdAt: DateTimeOutput;
  email: String;
}

export interface PaypalInformation
  extends Promise<PaypalInformationNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
  paymentAccount: <T = PaymentAccount>() => T;
}

export interface PaypalInformationSubscription
  extends Promise<AsyncIterator<PaypalInformationNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  email: () => Promise<AsyncIterator<String>>;
  paymentAccount: <T = PaymentAccountSubscription>() => T;
}

export interface NotificationConnectionNode {}

export interface NotificationConnection
  extends Promise<NotificationConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<NotificationEdgeNode>>() => T;
  aggregate: <T = AggregateNotification>() => T;
}

export interface NotificationConnectionSubscription
  extends Promise<AsyncIterator<NotificationConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<NotificationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateNotificationSubscription>() => T;
}

export interface PaymentAccountSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface PaymentAccountSubscriptionPayload
  extends Promise<PaymentAccountSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PaymentAccount>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PaymentAccountPreviousValues>() => T;
}

export interface PaymentAccountSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PaymentAccountSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PaymentAccountSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PaymentAccountPreviousValuesSubscription>() => T;
}

export interface AggregateMessageNode {
  count: Int;
}

export interface AggregateMessage
  extends Promise<AggregateMessageNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMessageSubscription
  extends Promise<AsyncIterator<AggregateMessageNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PaymentAccountPreviousValuesNode {
  id: ID_Output;
  createdAt: DateTimeOutput;
  type?: PAYMENT_PROVIDER;
}

export interface PaymentAccountPreviousValues
  extends Promise<PaymentAccountPreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  type: () => Promise<PAYMENT_PROVIDER>;
}

export interface PaymentAccountPreviousValuesSubscription
  extends Promise<AsyncIterator<PaymentAccountPreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  type: () => Promise<AsyncIterator<PAYMENT_PROVIDER>>;
}

export interface LocationEdgeNode {
  cursor: String;
}

export interface LocationEdge extends Promise<LocationEdgeNode>, Fragmentable {
  node: <T = Location>() => T;
  cursor: () => Promise<String>;
}

export interface LocationEdgeSubscription
  extends Promise<AsyncIterator<LocationEdgeNode>>,
    Fragmentable {
  node: <T = LocationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PaymentAccountNode {
  id: ID_Output;
  createdAt: DateTimeOutput;
  type?: PAYMENT_PROVIDER;
}

export interface PaymentAccount
  extends Promise<PaymentAccountNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  type: () => Promise<PAYMENT_PROVIDER>;
  user: <T = User>() => T;
  payments: <T = FragmentableArray<PaymentNode>>(
    args?: {
      where?: PaymentWhereInput;
      orderBy?: PaymentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  paypal: <T = PaypalInformation>() => T;
  creditcard: <T = CreditCardInformation>() => T;
}

export interface PaymentAccountSubscription
  extends Promise<AsyncIterator<PaymentAccountNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  type: () => Promise<AsyncIterator<PAYMENT_PROVIDER>>;
  user: <T = UserSubscription>() => T;
  payments: <T = Promise<AsyncIterator<PaymentSubscription>>>(
    args?: {
      where?: PaymentWhereInput;
      orderBy?: PaymentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  paypal: <T = PaypalInformationSubscription>() => T;
  creditcard: <T = CreditCardInformationSubscription>() => T;
}

export interface HouseRulesConnectionNode {}

export interface HouseRulesConnection
  extends Promise<HouseRulesConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<HouseRulesEdgeNode>>() => T;
  aggregate: <T = AggregateHouseRules>() => T;
}

export interface HouseRulesConnectionSubscription
  extends Promise<AsyncIterator<HouseRulesConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<HouseRulesEdgeSubscription>>>() => T;
  aggregate: <T = AggregateHouseRulesSubscription>() => T;
}

export interface PaypalInformationSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface PaypalInformationSubscriptionPayload
  extends Promise<PaypalInformationSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PaypalInformation>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PaypalInformationPreviousValues>() => T;
}

export interface PaypalInformationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PaypalInformationSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PaypalInformationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PaypalInformationPreviousValuesSubscription>() => T;
}

export interface UserSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface UserSubscriptionPayload
  extends Promise<UserSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = User>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValues>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface PaypalInformationPreviousValuesNode {
  id: ID_Output;
  createdAt: DateTimeOutput;
  email: String;
}

export interface PaypalInformationPreviousValues
  extends Promise<PaypalInformationPreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
}

export interface PaypalInformationPreviousValuesSubscription
  extends Promise<AsyncIterator<PaypalInformationPreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  email: () => Promise<AsyncIterator<String>>;
}

export interface AggregateExperienceNode {
  count: Int;
}

export interface AggregateExperience
  extends Promise<AggregateExperienceNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateExperienceSubscription
  extends Promise<AsyncIterator<AggregateExperienceNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PaymentNode {
  id: ID_Output;
  createdAt: DateTimeOutput;
  serviceFee: Float;
  placePrice: Float;
  totalPrice: Float;
}

export interface Payment extends Promise<PaymentNode>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  serviceFee: () => Promise<Float>;
  placePrice: () => Promise<Float>;
  totalPrice: () => Promise<Float>;
  booking: <T = Booking>() => T;
  paymentMethod: <T = PaymentAccount>() => T;
}

export interface PaymentSubscription
  extends Promise<AsyncIterator<PaymentNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  serviceFee: () => Promise<AsyncIterator<Float>>;
  placePrice: () => Promise<AsyncIterator<Float>>;
  totalPrice: () => Promise<AsyncIterator<Float>>;
  booking: <T = BookingSubscription>() => T;
  paymentMethod: <T = PaymentAccountSubscription>() => T;
}

export interface CreditCardInformationEdgeNode {
  cursor: String;
}

export interface CreditCardInformationEdge
  extends Promise<CreditCardInformationEdgeNode>,
    Fragmentable {
  node: <T = CreditCardInformation>() => T;
  cursor: () => Promise<String>;
}

export interface CreditCardInformationEdgeSubscription
  extends Promise<AsyncIterator<CreditCardInformationEdgeNode>>,
    Fragmentable {
  node: <T = CreditCardInformationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PictureSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface PictureSubscriptionPayload
  extends Promise<PictureSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = Picture>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PicturePreviousValues>() => T;
}

export interface PictureSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PictureSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PictureSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PicturePreviousValuesSubscription>() => T;
}

export interface ViewsEdgeNode {
  cursor: String;
}

export interface ViewsEdge extends Promise<ViewsEdgeNode>, Fragmentable {
  node: <T = Views>() => T;
  cursor: () => Promise<String>;
}

export interface ViewsEdgeSubscription
  extends Promise<AsyncIterator<ViewsEdgeNode>>,
    Fragmentable {
  node: <T = ViewsSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PicturePreviousValuesNode {
  id: ID_Output;
  url: String;
}

export interface PicturePreviousValues
  extends Promise<PicturePreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  url: () => Promise<String>;
}

export interface PicturePreviousValuesSubscription
  extends Promise<AsyncIterator<PicturePreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  url: () => Promise<AsyncIterator<String>>;
}

export interface ReviewEdgeNode {
  cursor: String;
}

export interface ReviewEdge extends Promise<ReviewEdgeNode>, Fragmentable {
  node: <T = Review>() => T;
  cursor: () => Promise<String>;
}

export interface ReviewEdgeSubscription
  extends Promise<AsyncIterator<ReviewEdgeNode>>,
    Fragmentable {
  node: <T = ReviewSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface BookingNode {
  id: ID_Output;
  createdAt: DateTimeOutput;
  startDate: DateTimeOutput;
  endDate: DateTimeOutput;
}

export interface Booking extends Promise<BookingNode>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  bookee: <T = User>() => T;
  place: <T = Place>() => T;
  startDate: () => Promise<DateTimeOutput>;
  endDate: () => Promise<DateTimeOutput>;
  payment: <T = Payment>() => T;
}

export interface BookingSubscription
  extends Promise<AsyncIterator<BookingNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  bookee: <T = UserSubscription>() => T;
  place: <T = PlaceSubscription>() => T;
  startDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  endDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  payment: <T = PaymentSubscription>() => T;
}

export interface PricingConnectionNode {}

export interface PricingConnection
  extends Promise<PricingConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<PricingEdgeNode>>() => T;
  aggregate: <T = AggregatePricing>() => T;
}

export interface PricingConnectionSubscription
  extends Promise<AsyncIterator<PricingConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PricingEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePricingSubscription>() => T;
}

export interface PlaceSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface PlaceSubscriptionPayload
  extends Promise<PlaceSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = Place>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PlacePreviousValues>() => T;
}

export interface PlaceSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PlaceSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PlaceSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PlacePreviousValuesSubscription>() => T;
}

export interface AggregatePictureNode {
  count: Int;
}

export interface AggregatePicture
  extends Promise<AggregatePictureNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePictureSubscription
  extends Promise<AsyncIterator<AggregatePictureNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PlacePreviousValuesNode {
  id: ID_Output;
  name: String;
  size?: PLACE_SIZES;
  shortDescription: String;
  description: String;
  slug: String;
  maxGuests: Int;
  numBedrooms: Int;
  numBeds: Int;
  numBaths: Int;
  popularity: Int;
}

export interface PlacePreviousValues
  extends Promise<PlacePreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  size: () => Promise<PLACE_SIZES>;
  shortDescription: () => Promise<String>;
  description: () => Promise<String>;
  slug: () => Promise<String>;
  maxGuests: () => Promise<Int>;
  numBedrooms: () => Promise<Int>;
  numBeds: () => Promise<Int>;
  numBaths: () => Promise<Int>;
  popularity: () => Promise<Int>;
}

export interface PlacePreviousValuesSubscription
  extends Promise<AsyncIterator<PlacePreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  size: () => Promise<AsyncIterator<PLACE_SIZES>>;
  shortDescription: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  slug: () => Promise<AsyncIterator<String>>;
  maxGuests: () => Promise<AsyncIterator<Int>>;
  numBedrooms: () => Promise<AsyncIterator<Int>>;
  numBeds: () => Promise<AsyncIterator<Int>>;
  numBaths: () => Promise<AsyncIterator<Int>>;
  popularity: () => Promise<AsyncIterator<Int>>;
}

export interface PaymentAccountConnectionNode {}

export interface PaymentAccountConnection
  extends Promise<PaymentAccountConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<PaymentAccountEdgeNode>>() => T;
  aggregate: <T = AggregatePaymentAccount>() => T;
}

export interface PaymentAccountConnectionSubscription
  extends Promise<AsyncIterator<PaymentAccountConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PaymentAccountEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePaymentAccountSubscription>() => T;
}

export interface RestaurantNode {
  id: ID_Output;
  createdAt: DateTimeOutput;
  title: String;
  avgPricePerPerson: Int;
  isCurated: Boolean;
  slug: String;
  popularity: Int;
}

export interface Restaurant extends Promise<RestaurantNode>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  title: () => Promise<String>;
  avgPricePerPerson: () => Promise<Int>;
  pictures: <T = FragmentableArray<PictureNode>>(
    args?: {
      where?: PictureWhereInput;
      orderBy?: PictureOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  location: <T = Location>() => T;
  isCurated: () => Promise<Boolean>;
  slug: () => Promise<String>;
  popularity: () => Promise<Int>;
}

export interface RestaurantSubscription
  extends Promise<AsyncIterator<RestaurantNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  title: () => Promise<AsyncIterator<String>>;
  avgPricePerPerson: () => Promise<AsyncIterator<Int>>;
  pictures: <T = Promise<AsyncIterator<PictureSubscription>>>(
    args?: {
      where?: PictureWhereInput;
      orderBy?: PictureOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  location: <T = LocationSubscription>() => T;
  isCurated: () => Promise<AsyncIterator<Boolean>>;
  slug: () => Promise<AsyncIterator<String>>;
  popularity: () => Promise<AsyncIterator<Int>>;
}

export interface NeighbourhoodEdgeNode {
  cursor: String;
}

export interface NeighbourhoodEdge
  extends Promise<NeighbourhoodEdgeNode>,
    Fragmentable {
  node: <T = Neighbourhood>() => T;
  cursor: () => Promise<String>;
}

export interface NeighbourhoodEdgeSubscription
  extends Promise<AsyncIterator<NeighbourhoodEdgeNode>>,
    Fragmentable {
  node: <T = NeighbourhoodSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PoliciesSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface PoliciesSubscriptionPayload
  extends Promise<PoliciesSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = Policies>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PoliciesPreviousValues>() => T;
}

export interface PoliciesSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PoliciesSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PoliciesSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PoliciesPreviousValuesSubscription>() => T;
}

export interface AggregateHouseRulesNode {
  count: Int;
}

export interface AggregateHouseRules
  extends Promise<AggregateHouseRulesNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateHouseRulesSubscription
  extends Promise<AsyncIterator<AggregateHouseRulesNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PoliciesPreviousValuesNode {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  checkInStartTime: Float;
  checkInEndTime: Float;
  checkoutTime: Float;
}

export interface PoliciesPreviousValues
  extends Promise<PoliciesPreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  checkInStartTime: () => Promise<Float>;
  checkInEndTime: () => Promise<Float>;
  checkoutTime: () => Promise<Float>;
}

export interface PoliciesPreviousValuesSubscription
  extends Promise<AsyncIterator<PoliciesPreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  checkInStartTime: () => Promise<AsyncIterator<Float>>;
  checkInEndTime: () => Promise<AsyncIterator<Float>>;
  checkoutTime: () => Promise<AsyncIterator<Float>>;
}

export interface ExperienceCategoryEdgeNode {
  cursor: String;
}

export interface ExperienceCategoryEdge
  extends Promise<ExperienceCategoryEdgeNode>,
    Fragmentable {
  node: <T = ExperienceCategory>() => T;
  cursor: () => Promise<String>;
}

export interface ExperienceCategoryEdgeSubscription
  extends Promise<AsyncIterator<ExperienceCategoryEdgeNode>>,
    Fragmentable {
  node: <T = ExperienceCategorySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CityNode {
  id: ID_Output;
  name: String;
}

export interface City extends Promise<CityNode>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  neighbourhoods: <T = FragmentableArray<NeighbourhoodNode>>(
    args?: {
      where?: NeighbourhoodWhereInput;
      orderBy?: NeighbourhoodOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface CitySubscription
  extends Promise<AsyncIterator<CityNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  neighbourhoods: <T = Promise<AsyncIterator<NeighbourhoodSubscription>>>(
    args?: {
      where?: NeighbourhoodWhereInput;
      orderBy?: NeighbourhoodOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface LocationNode {
  id: ID_Output;
  lat: Float;
  lng: Float;
  address: String;
  directions: String;
}

export interface Location extends Promise<LocationNode>, Fragmentable {
  id: () => Promise<ID_Output>;
  lat: () => Promise<Float>;
  lng: () => Promise<Float>;
  neighbourHood: <T = Neighbourhood>() => T;
  user: <T = User>() => T;
  place: <T = Place>() => T;
  address: () => Promise<String>;
  directions: () => Promise<String>;
  experience: <T = Experience>() => T;
  restaurant: <T = Restaurant>() => T;
}

export interface LocationSubscription
  extends Promise<AsyncIterator<LocationNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  lat: () => Promise<AsyncIterator<Float>>;
  lng: () => Promise<AsyncIterator<Float>>;
  neighbourHood: <T = NeighbourhoodSubscription>() => T;
  user: <T = UserSubscription>() => T;
  place: <T = PlaceSubscription>() => T;
  address: () => Promise<AsyncIterator<String>>;
  directions: () => Promise<AsyncIterator<String>>;
  experience: <T = ExperienceSubscription>() => T;
  restaurant: <T = RestaurantSubscription>() => T;
}

export interface PricingSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface PricingSubscriptionPayload
  extends Promise<PricingSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = Pricing>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PricingPreviousValues>() => T;
}

export interface PricingSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PricingSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PricingSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PricingPreviousValuesSubscription>() => T;
}

export interface RestaurantConnectionNode {}

export interface RestaurantConnection
  extends Promise<RestaurantConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<RestaurantEdgeNode>>() => T;
  aggregate: <T = AggregateRestaurant>() => T;
}

export interface RestaurantConnectionSubscription
  extends Promise<AsyncIterator<RestaurantConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<RestaurantEdgeSubscription>>>() => T;
  aggregate: <T = AggregateRestaurantSubscription>() => T;
}

export interface PricingPreviousValuesNode {
  id: ID_Output;
  monthlyDiscount?: Int;
  weeklyDiscount?: Int;
  perNight: Int;
  smartPricing: Boolean;
  basePrice: Int;
  averageWeekly: Int;
  averageMonthly: Int;
  cleaningFee?: Int;
  securityDeposit?: Int;
  extraGuests?: Int;
  weekendPricing?: Int;
  currency?: CURRENCY;
}

export interface PricingPreviousValues
  extends Promise<PricingPreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  monthlyDiscount: () => Promise<Int>;
  weeklyDiscount: () => Promise<Int>;
  perNight: () => Promise<Int>;
  smartPricing: () => Promise<Boolean>;
  basePrice: () => Promise<Int>;
  averageWeekly: () => Promise<Int>;
  averageMonthly: () => Promise<Int>;
  cleaningFee: () => Promise<Int>;
  securityDeposit: () => Promise<Int>;
  extraGuests: () => Promise<Int>;
  weekendPricing: () => Promise<Int>;
  currency: () => Promise<CURRENCY>;
}

export interface PricingPreviousValuesSubscription
  extends Promise<AsyncIterator<PricingPreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  monthlyDiscount: () => Promise<AsyncIterator<Int>>;
  weeklyDiscount: () => Promise<AsyncIterator<Int>>;
  perNight: () => Promise<AsyncIterator<Int>>;
  smartPricing: () => Promise<AsyncIterator<Boolean>>;
  basePrice: () => Promise<AsyncIterator<Int>>;
  averageWeekly: () => Promise<AsyncIterator<Int>>;
  averageMonthly: () => Promise<AsyncIterator<Int>>;
  cleaningFee: () => Promise<AsyncIterator<Int>>;
  securityDeposit: () => Promise<AsyncIterator<Int>>;
  extraGuests: () => Promise<AsyncIterator<Int>>;
  weekendPricing: () => Promise<AsyncIterator<Int>>;
  currency: () => Promise<AsyncIterator<CURRENCY>>;
}

export interface PaypalInformationEdgeNode {
  cursor: String;
}

export interface PaypalInformationEdge
  extends Promise<PaypalInformationEdgeNode>,
    Fragmentable {
  node: <T = PaypalInformation>() => T;
  cursor: () => Promise<String>;
}

export interface PaypalInformationEdgeSubscription
  extends Promise<AsyncIterator<PaypalInformationEdgeNode>>,
    Fragmentable {
  node: <T = PaypalInformationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PictureNode {
  id: ID_Output;
  url: String;
}

export interface Picture extends Promise<PictureNode>, Fragmentable {
  id: () => Promise<ID_Output>;
  url: () => Promise<String>;
}

export interface PictureSubscription
  extends Promise<AsyncIterator<PictureNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  url: () => Promise<AsyncIterator<String>>;
}

export interface MessageConnectionNode {}

export interface MessageConnection
  extends Promise<MessageConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<MessageEdgeNode>>() => T;
  aggregate: <T = AggregateMessage>() => T;
}

export interface MessageConnectionSubscription
  extends Promise<AsyncIterator<MessageConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MessageEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMessageSubscription>() => T;
}

export interface ExperienceConnectionNode {}

export interface ExperienceConnection
  extends Promise<ExperienceConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<ExperienceEdgeNode>>() => T;
  aggregate: <T = AggregateExperience>() => T;
}

export interface ExperienceConnectionSubscription
  extends Promise<AsyncIterator<ExperienceConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ExperienceEdgeSubscription>>>() => T;
  aggregate: <T = AggregateExperienceSubscription>() => T;
}

export interface ReviewSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface ReviewSubscriptionPayload
  extends Promise<ReviewSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = Review>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ReviewPreviousValues>() => T;
}

export interface ReviewSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ReviewSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ReviewSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ReviewPreviousValuesSubscription>() => T;
}

export interface NeighbourhoodNode {
  id: ID_Output;
  name: String;
  slug: String;
  featured: Boolean;
  popularity: Int;
}

export interface Neighbourhood
  extends Promise<NeighbourhoodNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  locations: <T = FragmentableArray<LocationNode>>(
    args?: {
      where?: LocationWhereInput;
      orderBy?: LocationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  name: () => Promise<String>;
  slug: () => Promise<String>;
  homePreview: <T = Picture>() => T;
  city: <T = City>() => T;
  featured: () => Promise<Boolean>;
  popularity: () => Promise<Int>;
}

export interface NeighbourhoodSubscription
  extends Promise<AsyncIterator<NeighbourhoodNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  locations: <T = Promise<AsyncIterator<LocationSubscription>>>(
    args?: {
      where?: LocationWhereInput;
      orderBy?: LocationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  name: () => Promise<AsyncIterator<String>>;
  slug: () => Promise<AsyncIterator<String>>;
  homePreview: <T = PictureSubscription>() => T;
  city: <T = CitySubscription>() => T;
  featured: () => Promise<AsyncIterator<Boolean>>;
  popularity: () => Promise<AsyncIterator<Int>>;
}

export interface RestaurantPreviousValuesNode {
  id: ID_Output;
  createdAt: DateTimeOutput;
  title: String;
  avgPricePerPerson: Int;
  isCurated: Boolean;
  slug: String;
  popularity: Int;
}

export interface RestaurantPreviousValues
  extends Promise<RestaurantPreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  title: () => Promise<String>;
  avgPricePerPerson: () => Promise<Int>;
  isCurated: () => Promise<Boolean>;
  slug: () => Promise<String>;
  popularity: () => Promise<Int>;
}

export interface RestaurantPreviousValuesSubscription
  extends Promise<AsyncIterator<RestaurantPreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  title: () => Promise<AsyncIterator<String>>;
  avgPricePerPerson: () => Promise<AsyncIterator<Int>>;
  isCurated: () => Promise<AsyncIterator<Boolean>>;
  slug: () => Promise<AsyncIterator<String>>;
  popularity: () => Promise<AsyncIterator<Int>>;
}

export interface RestaurantSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface RestaurantSubscriptionPayload
  extends Promise<RestaurantSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = Restaurant>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = RestaurantPreviousValues>() => T;
}

export interface RestaurantSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<RestaurantSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = RestaurantSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = RestaurantPreviousValuesSubscription>() => T;
}

export interface UserEdgeNode {
  cursor: String;
}

export interface UserEdge extends Promise<UserEdgeNode>, Fragmentable {
  node: <T = User>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdgeNode>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface GuestRequirementsEdgeNode {
  cursor: String;
}

export interface GuestRequirementsEdge
  extends Promise<GuestRequirementsEdgeNode>,
    Fragmentable {
  node: <T = GuestRequirements>() => T;
  cursor: () => Promise<String>;
}

export interface GuestRequirementsEdgeSubscription
  extends Promise<AsyncIterator<GuestRequirementsEdgeNode>>,
    Fragmentable {
  node: <T = GuestRequirementsSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateNotificationNode {
  count: Int;
}

export interface AggregateNotification
  extends Promise<AggregateNotificationNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateNotificationSubscription
  extends Promise<AsyncIterator<AggregateNotificationNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserPreviousValuesNode {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  firstName: String;
  lastName: String;
  email: String;
  password: String;
  phone: String;
  responseRate?: Float;
  responseTime?: Int;
  isSuperHost: Boolean;
}

export interface UserPreviousValues
  extends Promise<UserPreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  phone: () => Promise<String>;
  responseRate: () => Promise<Float>;
  responseTime: () => Promise<Int>;
  isSuperHost: () => Promise<Boolean>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  responseRate: () => Promise<AsyncIterator<Float>>;
  responseTime: () => Promise<AsyncIterator<Int>>;
  isSuperHost: () => Promise<AsyncIterator<Boolean>>;
}

export type Long = string;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point). 
*/
export type Float = number;

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  endpoint: `${process.env["PRISMA_ENDPOINT"]}`,
  secret: `${process.env["PRISMA_SECRET"]}`
});
export const prisma = new Prisma();
